
\documentclass[12pt]{book}
 
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb,scrextend}
\usepackage[style=numeric]{biblatex}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{english}
\newcommand{\cont}{\subseteq}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{amsmath}
\usepackage[mathscr]{euscript}
\let\euscr\mathscr \let\mathscr\relax% just so we can load this and rsfs
\usepackage[scr]{rsfso}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{multicol}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{makeidx} % Add this package for indexing
\usepackage{imakeidx}
\usepackage{pdfpages}
\usepackage{tikz}
\usetikzlibrary{shapes, positioning}
\makeindex % Enable indexing


\usepackage[colorlinks=false, pdfstartview=FitV, linkcolor=blue,
citecolor=blue, urlcolor=blue]{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codeblue}{RGB}{0,0,128}
\definecolor{codered}{RGB}{163,21,21}
\definecolor{codegreen}{RGB}{0,100,0}
\lstset{
    language=Python,
    basicstyle=\ttfamily,
    keywordstyle=\color{codeblue},
    stringstyle=\color{codered},
    commentstyle=\color{codegreen},
    showstringspaces=false,
    breaklines=true,
    frame=double,
    numbers=left,
    numberstyle=\small,
    captionpos=b
}

\DeclareMathOperator{\arcsec}{arcsec}
\DeclareMathOperator{\arccot}{arccot}
\DeclareMathOperator{\arccsc}{arccsc}
\newcommand{\ddx}{\frac{d}{dx}}
\newcommand{\dfdx}{\frac{df}{dx}}
\newcommand{\ddxp}[1]{\frac{d}{dx}\left( #1 \right)}
\newcommand{\dydx}{\frac{dy}{dx}}
\let\ds\displaystyle
\newcommand{\intx}[1]{\int #1 \, dx}
\newcommand{\intt}[1]{\int #1 \, dt}
\newcommand{\defint}[3]{\int_{#1}^{#2} #3 \, dx}
\newcommand{\imp}{\Rightarrow}
\newcommand{\un}{\cup}
\newcommand{\ps}{\mathscr{P}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\definition}[1]{\textbf{Definicja } #1}
\newtheorem*{sol}{Rozwi?zanie}
\newtheorem*{claim}{Wniosek}

\newtheorem{Example}{Example}[chapter]
\newtheorem{problem}{Zadanie}
\newtheorem{Def}{Definicja}
\newtheorem{The}{Twierdzenie}
\newtheorem*{Proof}{Dow?d}

\renewenvironment{Example}{\begin{trivlist}\item\relax
\textbf{Example \thesection: }}{\end{trivlist}}

\title{
    {Python Course Notes} \vspace{2cm} \\
    {\large Internatinal Programming School Algorithmics} \vspace{2cm}\\
   
    {\includegraphics[width=25mm]{logo.jpeg} \vspace{5c\dfrac{?}{?}m} } 
}

\author{
    \vspace{2cm} \\
    Associate Engineer \\
    Andrii Voznesenskyi \vspace{1cm} \\
    {\large Mathematics and Information Systems Faculty} \\
    {\large Warsaw University of Technologies} \vspace{2cm} \\
    Instructor
}
\date{May 12, 2023}

\addbibresource{./bibreferences.bib} % Replace with the actual name of your bibliography file
\begin{document}
\includepdf{python_cover.pdf}
 
% EVERYTHING ABOVE THIS LINE IS JUST PREABLE, NO NEED TO MESS WITH IT.__________________________________________________________________________________________
%


%\maketitle
\begin{titlepage}
    \begin{center}
    \vspace*{1cm}

    \vspace{1cm}
    
    \Huge
    \textbf{Python Course Notes}
    
    \vspace{2cm}
    \Large

    
    \vspace{2cm}
    \Large
    %\begin{flushright}
    \textbf{Course Instructor:} \\
    %\end{flushright}
    \begin{flushright}
    \large
    \textbf{Associate Engineer, Andrii Voznesenskyi} \\
    \end{flushright}
    \textbf{Mathematics and Information Systems Faculty}\\
    \textbf{Warsaw University of Technologies} \\
    \vspace*{2cm}
    \includegraphics[width=25mm]{logo.jpeg}
    \vspace{1cm}
    
    \vspace{0.5cm}
    \underline{\hspace{6cm}}
    
    
    \vfill
    \large
    \textbf{May 20, 2023}
    
    
\end{titlepage}

\thispagestyle{empty}
\newpage


 \vspace{2cm}
    
\begin{flushleft}
\vspace{2cm}
\Large
\textbf{License:}

\normalsize
\begin{flushleft}
This document is protected by copyright law and under the MIT License. Any unauthorized reproduction, distribution, or use of this document is strictly prohibited and may result in severe civil and criminal penalties under applicable laws. The owner of this copyright holds the exclusive rights to reproduce, distribute, and display this document.
\end{flushleft}

\vspace{2cm}
\Large
\textbf{Purpose:}

\normalsize
\begin{flushleft}

The primary purpose of this document is to serve as an educational guide and reference for students or individuals who are eager to expand their knowledge and understanding about Python programming language, specifically with regards to variables, types, lists, tuples, and dictionaries. The problems and solutions herein are intended to help individuals improve their coding skills, analytical thinking and problem-solving abilities. It is not intended for any commercial use. 
\end{flushleft}

    This document is intended for the exclusive use of colleagues or students seeking to enhance their individual understanding of the course and engage in self-education. It is of utmost importance to strictly adhere to the restrictions and copyright information provided within this document.
    \end{flushleft}
\thispagestyle{empty}
\end{center}
\newpage
\vfill
\begin{flushright}
\vspace*{\fill}
\vspace{10cm}

''Education is the kindling of a flame, not the filling of a vessel.''\\Socrates, Ancient Greek philosopher
\thispagestyle{empty}
\end{flushright}

\newpage
\lhead{Python Course}
\chead{ }
\rhead{\leftmark}


\tableofcontents

\printindex 

\newpage
% \maketitle
\chapter{Introduction}


Python is a high-level, interpreted dynamically-typed programming language. It was created by Guido van Rossum and first released in 1991. Python is designed to be highly readable, with a simple and consistent syntax that promotes readability and therefore reduces the cost of program maintenance. Now let's take a deeper dive into it.



If you've chosen to read this book, you might already have some understanding of Python and its significance as a valuable tool for learning. If not, you will likely discover the value of Python as you progress through this book and engage in a few projects. Before delving into the details, let's briefly explore why Python has gained popularity. In this chapter, we will adopt a question-and-answer format to address common queries posed by beginners.

\section{What Makes Python a Preferred Choice?}

Given the abundance of programming languages available today, this question naturally arises for newcomers. With approximately 1 million Python users at present, it is impossible to provide a definitive answer. The choice of programming tools often depends on unique constraints or personal preferences.

However, after teaching Python to numerous groups comprising over 3,000 students in the past 12 years, certain common themes have emerged. The primary factors that attract Python users can be summarized as follows:

\subsection{Software quality}

Many individuals appreciate Python's emphasis on readability, coherence, and overall software quality, setting it apart from other scripting languages. Python code is designed to be easily readable, promoting reusability and maintainability. Its consistent structure enables easy comprehension, even for those who didn't author it. Additionally, Python offers robust support for advanced software reuse mechanisms, such as object-oriented programming (OOP).

\subsection{Developer productivity}

Python significantly enhances developer productivity compared to compiled or statically typed languages like C, C++, and Java. Python code typically requires one-third to one-fifth the amount of code compared to equivalent C++ or Java code. This means less typing, reduced debugging, and easier maintenance. Python programs also execute instantly, without the lengthy compile and link steps required by some other tools, thereby accelerating programmer speed.

\subsection{Program portability}

Most Python programs run flawlessly across major computer platforms. Transferring Python code between Linux and Windows, for instance, usually involves a simple copy-paste operation. Moreover, Python offers multiple options for developing portable graphical user interfaces, database access programs, web-based systems, and more. Even operating system interfaces, including program launches and directory processing, are highly portable in Python.

\subsection{Support libraries}

Python comes with an extensive standard library, which provides a wide range of prebuilt and portable functionality. This library facilitates various application-level programming tasks, from text pattern matching to network scripting. Additionally, Python can be extended through both custom libraries and a vast collection of third-party application support software. The Python ecosystem offers tools for website development, numerical programming, serial port access, game development, and much more. The NumPy extension, for example, is often regarded as a free and more powerful alternative to the Matlab numeric programming system.

\subsection{Component integration}

Python scripts seamlessly integrate with other components of an application, thanks to a variety of integration mechanisms. This integration capability enables Python to serve as a tool for customizing and extending products. Presently, Python code can invoke C and C++ libraries, be called from C and C++ programs, integrate with Java and .NET components, communicate through frameworks like COM, interface with devices via serial ports, and interact over networks using interfaces such as SOAP, XML-RPC, and CORBA. Python is not a standalone tool but an interconnected part of the software landscape.

\subsection{Enjoyment}

Python's user-friendly nature and built-in toolset make programming a more enjoyable experience than a tedious chore. Although this aspect may be intangible, its positive impact on productivity is a significant advantage.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[
  every node/.style={
    align=center,
    rectangle,
    draw,
    rounded corners,
    fill=blue!20,
    minimum width=3cm,
    minimum height=1cm,
    text width=2.8cm,
    font=\small\sffamily
  },
  level distance=2cm,
  sibling distance=3cm
]
  \node[fill=none, text width=3cm, minimum width=5cm] {What Makes Python a Preferred Choice?}
    child { node {Software\\Quality} 
        child { node {Program\\Portability} }
        child { node {Support\\Libraries} }
    }
    child { node {Developer\\Productivity}
        child { node {Component\\Integration} }
        child { node {Enjoyment} }
    };
\end{tikzpicture}
\caption{Factors that make Python a preferred choice}
\label{fig:python_factors}
\end{figure}

Among these factors, the most compelling benefits for most Python users are software quality and increased productivity.

\subsection{Okay, but What's the Downside?}

After using Python for 17 years and teaching it for 12, the only downside I've found is that, as currently implemented, its execution speed may not always match that of compiled languages like C and C++.

We will discuss implementation concepts in detail later in this book. In short, the standard implementations of Python today compile source code statements to an intermediate format called byte code and then interpret the byte code. Byte code provides portability as a platform-independent format. However, since Python is not compiled all the way down to binary machine code, some programs may run more slowly in Python than in a fully compiled language like C.

Whether you will ever be concerned about the execution speed difference depends on the types of programs you write. Python has been optimized numerous times, and Python code runs fast enough in most application domains. Furthermore, when performing "real" tasks in a Python script, such as processing a file or constructing a graphical user interface (GUI), your program will run at C speed, as such tasks are immediately dispatched to compiled C code inside the Python interpreter. Moreover, Python's speed of development often outweighs any loss in speed of execution, particularly given modern computer speeds.

However, there are some domains that require optimal execution speeds, such as numeric programming and animation. In such cases, you can still use Python by splitting off the parts of the application that require optimal speed into compiled extensions and linking them into your system for use in Python scripts.

We won't delve into extensions much in this text, but this is essentially an instance of Python serving as a control language, as discussed earlier. A prime example of this dual-language strategy is the NumPy numeric programming extension for Python. By combining compiled and optimized numeric extension libraries with the Python language, NumPy turns Python into an efficient and easy-to-use numeric programming tool. You may not need to code such extensions in your own Python work, but they provide a powerful optimization mechanism if the need arises.

\section{Who Uses Python Today?}

At present, the best estimate of the size of the Python user base is that there are roughly 1 million Python users worldwide. This estimate is based on various statistics, such as download rates and developer surveys. Due to its open-source nature, obtaining an exact count is challenging, as there are no license registrations to tally. Additionally, Python is automatically included with Linux distributions, Macintosh computers, and some products and hardware, further complicating the user-base picture.

However, it is evident that Python enjoys a large user base and a very active developer community. Python has been around for approximately 19 years, widely used, and proven to be stable and robust. Besides individual users, Python is being applied in revenue-generating products by real companies. Some notable examples include:

\begin{itemize}
  \item Google, which extensively uses Python in its web search systems and employs Python's creator.
  \item The YouTube video sharing service, which is largely written in Python.
  \item The popular BitTorrent peer-to-peer file sharing system, which is a Python program.
  \item Google's App Engine web development framework, which uses Python as its application language.
  \item EVE Online, a Massively Multiplayer Online Game (MMOG), which makes extensive use of Python.
  \item Maya, a powerful integrated 3D modeling and animation system, which provides a Python scripting API.
  \item Various companies like Intel, Cisco, Hewlett-Packard, Seagate, Qualcomm, and IBM, which use Python for hardware testing.
  \item Industrial Light \& Magic, Pixar, and others, which use Python in the production of animated movies.
  \item Financial institutions like JPMorgan Chase, UBS, Getco, and Citadel, which apply Python for financial market forecasting.
  \item NASA, Los Alamos, Fermilab, JPL, and others, which use Python for scientific programming tasks.
  \item iRobot, which uses Python to develop commercial robotic devices.
  \item ESRI, which uses Python as an end-user customization tool for its popular GIS mapping products.
  \item The NSA, which uses Python for cryptography and intelligence analysis.
  \item The IronPort email server product, which uses more than 1 million lines of Python code.
  \item The One Laptop Per Child (OLPC) project, which builds its user interface and activity model in Python.
\end{itemize}

This list is far from exhaustive, but it serves to illustrate Python's wide range of application domains. Python's general-purpose nature makes it applicable to almost all fields, not just one. In fact, it's safe to say that virtually every substantial organization writing software is using Python, whether for short-term tactical tasks, such as testing and administration, or for long-term strategic product development.

For further details on companies using Python today, you can visit Python's website at \texttt{http://www.python.org}.

\section{What Can You Do with Python?}

In addition to being a well-designed programming language, Python is useful for accomplishing real-world tasks?tasks that developers face every day. It is commonly used in various domains as a tool for scripting, integrating components, and implementing standalone programs. Python's applications are virtually unlimited, from website development and gaming to robotics and spacecraft control.

However, the most common Python roles today can be classified into a few broad categories. The following sections provide a brief overview of some of Python's most popular applications, along with the tools used in each domain. Keep in mind that we won't explore these tools in depth here; if you are interested in any of these topics, you can refer to the Python website or other resources for more details.

\subsection{Systems Programming}

Python's built-in interfaces to operating system services make it ideal for writing portable and maintainable system administration tools and utilities, often referred to as shell tools. Python programs can search files and directory trees, launch other programs, perform parallel processing with processes and threads, and more.

Python's standard library includes POSIX bindings and supports various OS tools, such as environment variables, files, sockets, pipes, processes, threads, regular expression pattern matching, command-line arguments, standard stream interfaces, shell-command launchers, filename expansion, and more. Additionally, most of Python's system interfaces are designed to be portable. For example, a script that copies directory trees usually runs unchanged on all major Python platforms. The Stackless Python system, used by EVE Online, offers advanced solutions for multiprocessing requirements.

\subsection{GUIs}

Python's simplicity and rapid development cycle make it well-suited for graphical user interface (GUI) programming. Python includes a standard object-oriented interface to the Tk GUI API called tkinter (Tkinter in Python 2.6). This interface allows Python programs to create portable GUIs with a native look and feel. Python/tkinter GUIs run on Microsoft Windows, X Windows (Unix and Linux), and Mac OS (both Classic and OS X). The PMW extension package adds advanced widgets to the tkinter toolkit. Additionally, the wxPython GUI API, based on a C++ library, provides an alternative toolkit for creating portable GUIs in Python.

Higher-level toolkits like PythonCard and Dabo are built on top of base APIs such as wxPython and tkinter. With the appropriate libraries, you can also utilize GUI support from other toolkits in Python, such as PyQt for Qt, PyGTK for GTK, PyWin32 for MFC, IronPython for .NET, and Jython (the Java version of Python, described in Chapter 2) or JPype for Swing. For web-based applications or simple interface requirements, Jython and Python web frameworks, along with server-side CGI scripts, offer additional options for user interface development.

\subsection{Internet Scripting}

Python provides standard internet modules that enable programs to perform a wide range of networking tasks in client and server modes. Scripts can communicate over sockets, extract form information from server-side CGI scripts, transfer files via FTP, parse and generate XML files, send, receive, compose, and parse emails, fetch web pages via URLs, parse HTML and XML from web pages, communicate over XML-RPC, SOAP, and Telnet, and much more. Python's libraries simplify these tasks significantly.

Additionally, numerous third-party tools are available on the web for internet programming in Python. For example, the HTMLGen system generates HTML files from Python class-based descriptions, the mod\_python package efficiently runs Python within the Apache web server and supports server\dash side templating with its Python Server Pages, and the Jython system enables seamless Python\slash Java integration and server-side applet coding for clients.

Moreover, full-fledged web development framework packages for Python, such as Django, TurboGears, web2py, Pylons, Zope, and WebWare, allow rapid construction of feature-rich, production-quality websites. Many of these frameworks include object-relational mappers, a Model\slash View\slash Controller architecture, server\dash side scripting and templating, and AJAX support, providing complete and enterprise\dash level web development solutions.

\subsection{Component Integration}

Python's ability to be extended by and embedded in C and C++ systems makes it useful as a flexible glue language for scripting the behavior of other systems and components. For instance, integrating a C library into Python allows Python to test and launch the library's components. Similarly, embedding Python in a product facilitates on \dash site customizations without recompiling the entire product or shipping its source code.

Tools like SWIG and SIP can automate much of the work required to link compiled components into Python for use in scripts, while the Cython system enables developers to mix Python and C\-like code. Larger frameworks, such as Python's COM support on Windows, the Jython Java-based implementation, the IronPython .NET\-based implementation, and various CORBA toolkits for Python, provide alternative ways to script components. On Windows, for instance, Python scripts can use frameworks to script Word and Excel.

\subsection{Database Programming}

Python provides interfaces to commonly used relational database systems, including Sybase, Oracle, Informix, ODBC, MySQL, PostgreSQL, and SQLite, among others. The Python community has defined a portable database API that allows Python scripts to access SQL database systems using a consistent interface. This means that a script developed for the free MySQL system will often work unchanged on other systems, such as Oracle, by simply replacing the underlying vendor interface.

Python's standard pickle module offers a simple object persistence system, allowing programs to easily save and restore Python objects to files and file-like objects. Additionally, third-party open-source systems like ZODB provide complete object-oriented database systems for Python scripts, and others, such as SQLObject and SQLAlchemy, map relational tables onto Python's class model. Furthermore, starting from Python 2.5, the in-process SQLite embedded SQL database engine is included as a standard part of Python.

\subsection{Rapid Prototyping}

Python programs can interact with components written in both Python and C, treating them the same way. This allows developers to prototype systems using Python and subsequently move selected components to a compiled language like C or C++ for delivery. Unlike some prototyping tools, Python doesn't necessitate a complete rewrite once the prototype solidifies. Python can coexist seamlessly with compiled languages, enabling developers to optimize performance-critical sections while retaining other parts of the system in Python for ease of maintenance and use.

\subsection{Numeric and Scientific Programming}

The NumPy numeric programming extension for Python is one of the most notable tools in this domain. It includes an array object, interfaces to standard mathematical libraries, and more. By integrating Python with numeric routines coded in a compiled language for speed, NumPy transforms Python into a sophisticated yet easy-to-use numeric programming tool that can often replace code written in traditional compiled languages such as FORTRAN or C++. Additional numeric tools for Python support animation, 3D visualization, parallel processing, and other tasks. The SciPy and ScientificPython extensions, for example, provide additional libraries for scientific programming and leverage NumPy functionality.

\subsection{Gaming, Images, Serial Ports, XML, Robots, and More}

Python finds applications in numerous other domains as well. For instance, you can use Python for game programming and multimedia with the pygame system, serial port communication on various platforms with the PySerial extension, image processing with libraries like PIL, PyOpenGL, Blender, and Maya, robot control programming with the PyRo toolkit, XML parsing with the xml library package, the xmlrpclib module, and third-party extensions, artificial intelligence programming with neural network simulators and expert system shells, and natural language analysis with the NLTK package. There are even programs like PySol that allow you to play solitaire. Support for many of these fields can be found on the Python Package Index (PyPI) website and through web searches.

This list is by no means exhaustive, but it demonstrates the wide range of applications Python can handle. Python's ability to integrate components and its general-purpose nature make it applicable in a wide variety of domains.

\section{How Is Python Supported?}

Python is an open-source system with a large and active development community that responds quickly to issues and develops enhancements at an impressive pace. Python developers coordinate their work online using a source-control system. Changes to the language follow a formal Python Enhancement Proposal (PEP) protocol and undergo scrutiny from other developers and the BDFL (Benevolent Dictator For Life), Guido van Rossum, the creator of Python.

The Python community is known for its rapid response to user queries and issues, providing support that many commercial software help desks would find challenging to match. Python's complete source code is available, empowering developers to study or modify the language's implementation as needed. Unlike commercial software, Python is not subject to the whims of a single vendor, and its ultimate documentation source is accessible to all.

The Python Software Foundation (PSF), a formal nonprofit organization, plays a key role in organizing conferences and addressing intellectual property issues. Python conferences, such as O'Reilly's OSCON and the PSF's PyCon, provide platforms for developers to share knowledge and experiences. PyCon, in particular, has experienced significant growth in recent years, attracting a large number of attendees. The Python community remains highly active and engaged in the ongoing development and support of the language.

\section{What Are Python's Technical Strengths?}

Python boasts several technical strengths that make it a popular choice among developers. Here are some of its key features:

\textbf{Object-Oriented:} Python is an object-oriented language that supports advanced concepts like polymorphism, operator overloading, and multiple inheritance. Despite these powerful features, Python's simple syntax and typing make it easy to apply object-oriented programming (OOP) principles. Python allows developers to use OOP when necessary but also supports procedural programming. This flexibility makes Python an ideal scripting tool for object-oriented systems languages like C++ and Java.

\textbf{Free and Open Source:} Python is completely free to use and distribute. It is an open-source language, meaning its complete source code is available for free on the internet. There are no restrictions on copying, embedding, or shipping Python with your products. Python's open-source nature also means that it benefits from a large and active development community, which continuously enhances and supports the language.

\textbf{Portability:} The standard implementation of Python is written in portable ANSI C and runs on virtually every major platform. Python programs can be executed on a wide range of systems, from Linux and Windows to Mac OS, BeOS, and even gaming consoles and cell phones. Python's standard library modules are designed to be portable across platforms, enabling developers to write code that runs consistently on different systems.

It's worth noting that Python's portability extends to its byte code, which is a platform-independent format. Python programs are compiled to byte code, which can be executed by any Python interpreter on any platform. This allows for easy distribution and execution of Python programs across different systems.

\textbf{Expressive and Readable Syntax:} Python's syntax is designed to be highly readable and expressive. It emphasizes code readability, making it easier for developers to write and maintain Python programs. Python code is often referred to as "executable pseudo-code" due to its natural language-like syntax. The use of whitespace indentation for code blocks, rather than curly braces or keywords, further enhances the readability of Python code.

\textbf{Large Standard Library:} Python comes with a large standard library that provides a wide range of functionality. The standard library includes modules for file I/O, network programming, database access, GUI development, regular expressions, unit testing, web scraping, and much more. This extensive collection of modules allows developers to leverage prebuilt functionality and accelerate the development process.

\textbf{Third-Party Libraries and Ecosystem:} In addition to its standard library, Python has a vibrant ecosystem of third-party libraries and frameworks. The Python Package Index (PyPI) hosts thousands of open-source packages that extend Python's capabilities in various domains. These packages cover areas such as web development, data analysis, machine learning, scientific computing, game development, and more. The availability of a rich set of third-party libraries allows developers to find and integrate solutions quickly, saving time and effort.

\section{Conclusion}

Python is a powerful and versatile programming language that has gained popularity due to its simplicity, readability, and extensive ecosystem. It offers numerous benefits, such as high software quality, developer productivity, program portability, support libraries, component integration, and an enjoyable programming experience. Python is widely used in various domains, including web development, scientific programming, system administration, GUI programming, and more. It is supported by a large and active community, providing rapid responses and continuous development. Python's technical strengths, such as being object-oriented, free and open source, portable, and having an expressive syntax, contribute to its widespread adoption and success in the software development industry.

We hope this introduction has piqued your interest in Python and its capabilities. Whether you're a beginner or an experienced programmer, Python offers a powerful and enjoyable environment for developing a wide range of applications. Happy coding!


\chapter{Installation}
Python is a versatile programming language that can be installed on various operating systems, including Windows, macOS, and Linux. In this chapter, we will explore the installation process for each of these platforms.

To install Python, you can download the latest version from the official Python website. Python can run on a variety of platforms including Windows, Mac, and various distributions of Linux. There are also several distributions of Python for specific purposes like Anaconda, which is focused on data analysis and scientific computing.


\section{Python on Linux}

Many Linux distributions come with Python pre-installed, but the versions might vary. To install the latest version or manage different Python versions, you can use package managers like \texttt{apt} (for Debian-based distributions) or \texttt{dnf} (for Fedora-based distributions). Here's an example of installing Python on Ubuntu using \texttt{apt}:

1. Open a terminal: \texttt{Ctrl + Alt + T} key shortcut was originally the one to open a terminal window in the Arch distributions.

2. Update package lists: Enter the following command to update the package lists:

   \texttt{sudo apt update}

3. Install Python: Enter the following command to install Python 3:

   \texttt{sudo apt install python3}

4. Verify the installation: Once the installation is complete, you can check the installed version by entering the command \texttt{python3 --version}.

Note that the package manager commands may differ depending on your Linux distribution. Refer to your distribution's documentation for the specific instructions.

\section{Python on macOS}

macOS usually comes with a pre-installed version of Python. However, it is recommended to install the latest version to ensure compatibility with the latest features and libraries. Follow these steps to install Python on macOS:

1. Check the installed version: Open the Terminal application by searching for it in Spotlight. Then, enter the command \texttt{python --version} and press Enter. If a Python version is displayed (e.g., Python 3.9.6), it means Python is already installed. You can skip the installation if the version is up to date.

2. Download the Python installer: Visit the official Python website at
 \texttt{{\href{https://www.python.org/downloads}{python.org/downloads}}} using a web browser. Look for the macOS installer section and click on the Python 3 download button.

3. Run the installer: Once the installer is downloaded, double-click on it to start the installation process. Follow the on-screen instructions, and make sure to select the option to install Python for all users and to add Python to the system's PATH.

4. Verify the installation: After the installation is complete, open a new Terminal window and enter the command \texttt{python --version} again. It should display the newly installed Python version, confirming a successful installation.



\section{Python on Windows}

Windows systems do not come with Python pre-installed, so we need to download and install it manually. Here's a step-by-step guide to installing Python on Windows:

1. Check if Python is already installed: Open a command prompt by pressing the Windows key and typing "Command Prompt." Then, enter the command \texttt{python} and press Enter. If Python is installed, you will see a Python prompt (\texttt{>>>}). Otherwise, you will see an error message indicating that Python is not recognized as a command.

2. Download the Python installer: Go to the official Python website at  \texttt{{\href{https://www.python.org/downloads}{python.org/downloads}}}  using a web browser. You will find two buttons labeled "Download Python 3" and "Download Python 2". It is recommended to choose the Python 3 version unless you have specific reasons to use Python 2. Click on the Python 3 button to download the installer.

3. Run the installer: Once the installer is downloaded, double-click on it to run the installation wizard. Make sure to select the option "Add Python to PATH" during the installation process. This option ensures that Python is added to the system's environment variables, allowing you to run Python from any location in the command prompt.

4. Verify the installation: After the installation is complete, open a new command prompt and enter the command \texttt{python} again. This time, it should launch the Python prompt without any errors, indicating a successful installation.



\section{IDE (Integrated Development Environment)}
An IDE is a software application that provides a comprehensive environment for writing, debugging, and running code. While Python can be written using any text editor, using an IDE can enhance your productivity and provide useful features like code completion, debugging tools, and project management.

One popular IDE for Python development is Visual Studio Code (VSCode). It is a free and open-source IDE developed by Microsoft. Here are some reasons why you might consider using VSCode for your Python programming:

\begin{itemize}
  \item \textbf{Cross-platform}: VSCode is available for Windows, macOS, and Linux, making it a versatile choice regardless of your operating system.
  \item \textbf{Extensible}: VSCode has a rich extension ecosystem, allowing you to customize and enhance your development experience. There are numerous Python-related extensions available that provide additional features and integrations.
  \item \textbf{Intelligent coding assistance}: VSCode offers features like code completion, syntax highlighting, linting, and code formatting, which can help you write cleaner and error-free code.
  \item \textbf{Integrated terminal}: VSCode provides an integrated terminal within the IDE, allowing you to run Python code and execute commands without switching to an external terminal.
  \item \textbf{Version control integration}: VSCode has built-in support for version control systems like Git, making it easy to manage and track changes in your code.
\end{itemize}

To install Visual Studio Code (VSCode) as your IDE for Python programming, you can follow these steps:


\begin{enumerate}
  \item Visit the official VSCode website at \url{https://code.visualstudio.com/} using a web browser.
  \item Download the appropriate installer for your operating system (Windows, macOS, or Linux).
  \item Run the installer executable and follow the instructions to complete the installation.
  \item Once the installation is complete, launch VSCode.
\end{enumerate}

To start coding in Python using VSCode, you can install the Python extension by Microsoft. Here's how:

\begin{enumerate}
  \item Open VSCode and click on the Extensions icon on the sidebar (or use the shortcut Ctrl+Shift+X).
  \item Search for "Python" in the Extensions Marketplace.
  \item Click on the "Python" extension by Microsoft and click on the "Install" button.
  \item After the installation is complete, you can use VSCode to write, debug, and run Python code.
\end{enumerate}
Remember that choosing an IDE is a personal preference, and there are many other IDEs available for Python development. You can explore different options and select the one that suits your needs and workflow the best.


\chapter{Your First Python Program}

Starting out in programming can be challenging. The syntax, concepts, and logic involved may seem overwhelming at first. The Python language, with its unique features and flexibility, can sometimes add to the confusion. However, like any other skill, programming can be mastered with dedication and hard work.

In this chapter, we will guide you through writing your first Python program and introduce you to some key points of the language. Remember, even the most experienced programmers were once beginners, facing similar obstacles. With determination and perseverance, you can overcome any initial difficulties and unlock the vast world of programming.

Here's how you can write your first Python program. This simple program outputs the string "Hello, World!" to the console:
\begin{Example}
For performing the example below with a full correctness, create a new file with the name \texttt{my\_first\_program\_in\_python.py} and inside the file created write the following content of the example: 
\begin{lstlisting}[language=Python]
print("Hello, World!")
\end{lstlisting}
\end{Example}

You may easily save the written program=, as most of IDE support \texttt{Ctrl + S} shortcut and you may than run the program from the terminal by using the next script: 
\texttt{python3 my\_first\_program\_in\_python.py}. At all next chapters the information about the program execution will not be mentioned in cate the program is believed to be quite simple.



\section{The print() function}
The print() function is a built-in function in Python that is used to output or display information to the console or terminal. It takes one or more arguments (values or expressions) and displays them as text.

In the example above, the print() function is used to display the string "Hello, World!" to the console. The string is enclosed in double quotation marks, indicating that it is a string literal.

You can also use single quotation marks to enclose strings. Both double and single quotation marks are valid ways to define strings in Python. In the example 3.0 you might note that the only one way of the quotation marks for the string argument was shown. Below you may also see the other ways of the usage:
\begin{Example}
For performing the example below with a full correctness, create a new file with the name \texttt{my\_first\_program\_in\_python.py} and inside the file created write the following content of the example: 
\begin{lstlisting}[language=Python]
print('Hello, World!')
print('''Hello, World!''')
print("""Hello, World!""")
\end{lstlisting}
\end{Example}

In the updated code of example 3.0 expansion, three different ways of using quotation marks for defining strings are shown:

\begin{itemize}
    \item The first example uses single quotation marks \texttt{('Hello, World!')} to enclose the string.
    \item The second example uses triple single quotation marks \texttt{('''Hello, World!''')} to enclose the string. This allows the string to span multiple lines.
    \item The third example uses triple double quotation marks \texttt{("""Hello, World!""")} to enclose the string. Similar to triple single quotation marks, this also allows the string to span multiple lines.
\end{itemize}

All three ways are valid in Python, and you can choose the one that suits your preference or the requirements of your code.



\section{Using f-strings with the print() function}
In addition to printing simple strings, you can use f-strings (formatted string literals) with the print() function to dynamically format and display values within a string.

To use an f-string, you prefix the string with the letter f or F and enclose the expression you want to evaluate within curly braces {}.

Here's an example that demonstrates the usage of an f-string with the print() function:

\begin{Example}
\begin{lstlisting}[language=Python]
name = "Alice"
age = 25
print(f"My name is {name} and I am {age} years old.")
\end{lstlisting}
\end{Example}

When this program is executed, it will output the following text to the console:

\begin{verbatim}
My name is Alice and I am 25 years old.
\end{verbatim}

In the f-string, the expressions {name} and {age} are evaluated and their values are inserted into the string at the respective positions.

F-strings are a powerful feature in Python that allow you to easily format strings with variables or expressions. They provide a concise and readable way to combine text and values in output statements.


\section{Using the print() function's properties}

The print() function in Python has some useful properties that can be used to modify its behavior. Here are a few commonly used properties:

\begin{itemize}
\item \textbf{sep}: This property allows you to specify the separator between multiple arguments passed to the print() function. By default, the separator is a space character. You can change it by assigning a different value to print()'s sep property.

\item \textbf{end}: This property allows you to specify the string that should be printed at the end of the print() function's output. By default, the end property is set to a newline character (\n), which causes the next output to appear on a new line. You can change it by assigning a different value to print()'s end property.

\item \textbf{file}: This property allows you to redirect the output of the print() function to a file or a different output stream instead of the default standard output (console). By default, the file property is set to sys.stdout, which represents the standard output. You can change it by assigning a different file object or output stream to print()'s file property.

\end{itemize}

Here's an example that demonstrates the usage of these properties:

\begin{Example}
\begin{lstlisting}[language=Python]
name = "Alice"
age = 25
output_file = open("output.txt", "w")

print(f"My name is {name}", end=", ")
print(f"and I am {age} years old.", file=output_file, sep="|")

output_file.close()
\end{lstlisting}
\end{Example}

In this example, we have set the end property of the first print() statement to ", " to print a comma followed by a space instead of the default newline character. We have also set the file property of the second print() statement to output\_file, which is a file object representing a file named "output.txt". Additionally, we have set the sep property of the second print() statement to "\textbar{}" to separate the two arguments with a pipe character. Actually, the reading and writing to the files operation will be covered with more precision a bit later.
The author would like you also to note the the words "\texttt{name}" and "\texttt{age}" are some specific words called variables, the whole sense of which will be covered in the next chapter.

When this program is executed, it will print the following text to the console:

\begin{verbatim}
My name is Alice, and I am 25 years old.
\end{verbatim}

It will also create a file named "output.txt" with the following content:

\begin{verbatim}
My name is Alice|and I am 25 years old.
\end{verbatim}

These properties provide flexibility in controlling the output format and destination when using the print() function in Python. The example 3.3. is provided here to make the reader's understandance quite a bit wider for a while, in this place the feeling of disorientation and unfavorable desire to learn is expected, however wait for a short while and you will know that there is nothing to be like the elephant out of the room. 

\section{Using the print().format() function in Python}


The \texttt{print().format()} function in Python is a versatile tool for formatting strings. It allows you to dynamically insert values into a string and control the formatting of those values. This can be incredibly useful when you need to create well-formatted and customizable output. Let's explore the capabilities of this function with some examples:

\begin{enumerate}
    \item Basic usage: \\
    \begin{lstlisting}[language=Python]
    print("Hello, {}. You are {} years old.".format("Alice", 25))
    \end{lstlisting}
    Output: "Hello, Alice. You are 25 years old." 
    
    In this example, the curly braces {} act as placeholders, which will be replaced by the values provided in the \texttt{format()} method, in the order they appear. This allows you to dynamically insert values into a string.

    \item Positional arguments: \\
    \begin{lstlisting}[language=Python]
    print("{1}, {0}".format("world", "Hello"))
    \end{lstlisting}
    Output: "Hello, world". The numbers inside the curly braces represent the index of the arguments in the \texttt{format()} method. By specifying the index of each argument, you can control their order in the resulting string. This is especially useful when you want to rearrange the values or reuse them multiple times.

    \item Named arguments: \\
    \begin{lstlisting}[language=Python]
    print("{greeting}, {name}".format(greeting="Hello", name="world"))
    \end{lstlisting}
    Output: "Hello, world". The strings inside the curly braces represent the names of the arguments in the \texttt{format()} method. Using named arguments allows you to specify values based on their corresponding names, rather than their positions. This provides clarity and flexibility when dealing with complex formatting scenarios.

\end{enumerate}

The general syntax for the \texttt{print().format()} function is as follows:

\begin{verbatim}
print(<format_string>.format(<arguments>))
\end{verbatim}

Here, \texttt{<format\_string>} is the string containing the placeholders and desired formatting, and <arguments> are the values or variables that will be inserted into the placeholders. The placeholders can be positioned by index or named, giving you fine-grained control over the arrangement of values within the output string.

By utilizing the \texttt{print().format()} function, you can achieve precise and customizable string formatting, making it a powerful tool for string manipulation and display in Python. This flexibility empowers you to create visually appealing and informative outputs, enhancing the overall quality and professionalism of your Python programs.
\section{Problems}

\begin{enumerate}
\item Write a Python program that prints your name.
\item Write a Python program that prints the sum of two numbers.
\item Write a Python program that prints the product of three numbers.
\item Write a Python program that prints the result of dividing two numbers.
\item Write a Python program that prints the remainder of dividing two numbers.
\item Write a Python program that prints the square root of a number.
\item Write a Python program that prints the absolute value of a number.
\item Write a Python program that prints a sentence using the f-string format.
\item Write a Python program that prints the result of an arithmetic expression using f-strings.
\item Write a Python program that prints a message using the .format() method.
\item Write a Python program that prints the result of an arithmetic expression using the .format() method.
\item Write a Python program that prints a sentence with multiple placeholders using f-strings.
\item Write a Python program that prints a sentence with named placeholders using the .format() method.
\item Write a Python program that prints a formatted date using f-strings.
\item Write a Python program that prints a formatted time using the .format() method.
\item Write a Python program that prints a formatted floating-point number using f-strings.
\item Write a Python program that prints a formatted integer using the .format() method.
\item Write a Python program that prints a sentence with multiple formatted values using f-strings.
\item Write a Python program that prints a sentence with multiple formatted values using the .format() method.
\item Write a Python program that prints a complex sentence with multiple placeholders and formatted values using f-strings and the .format() method.
\end{enumerate}


\chapter{Variables and Types}

Those acquainted with more basic languages like C or C++, are well aware that a significant part of their work involves creating objects or data structures, representing components in their applications. This involves the painstaking work of structuring memory, administering memory allocation, crafting search and access routines, amongst other things. These tasks are indeed as monotonous and error-prone as they sound, and they tend to divert focus from the actual objectives of your program.

However, in Python, much of this laborious work becomes unnecessary. This is owing to Python's in-built powerful object types that are integral to the language. This means that there is seldom a need to code object implementations prior to solving problems. Indeed, unless you require special processing that in-built types do not offer, it is often better to use an in-built object rather than creating your own. Here are some reasons:

\begin{itemize}
\item In-built objects simplify programming. For basic tasks, in-built types are frequently all you require to represent the structure of problem domains. Since collections such as lists and search tables such as dictionaries are immediately available, they can be employed straight away. A great deal of work can be accomplished using Python's in-built object types alone.

\item In-built objects serve as components of extensions. For more intricate tasks, you might need to provide your own objects using Python classes or C language interfaces. However, as we will see later, objects implemented manually are often built on top of in-built types such as lists and dictionaries. For instance, a stack data structure may be implemented as a class that manages or customises a built-in list.

\item In-built objects tend to be more efficient than custom data structures. Python's in-built types utilise optimised data structure algorithms which are implemented in C for speed. Even though you can write similar object types on your own, achieving the performance level that in-built object types provide can be quite challenging.

\item In-built objects are a standard part of the language. Python to some extent borrows from languages that rely on built-in tools (e.g., LISP) and languages that depend on the programmer to provide tool implementations or frameworks of their own (e.g., C++). Even though you can implement unique object types in Python, you do not need to do so just to get started. Furthermore, as Python's built-ins are standard, they are always the same; proprietary frameworks, conversely, tend to vary from site to site.
\end{itemize}

To sum up, not only do built-in object types simplify programming, but they are also more potent and efficient than most that can be created from scratch. Regardless of whether you implement new object types, built-in objects form the backbone of every Python program.

In Python, variables are created when you assign a value to them. Python is dynamically typed, which means that you don't need to specify the type of a variable when you declare it. Here's an example of variable assignment in Python:
\begin{Example}
\begin{lstlisting}[language=Python]
x = 5
y = "Hello, World!"
\end{lstlisting}
\end{Example}
In this example, $x$ is an integer and $y$ is a string.

Variables in Python can store values of different types, such as integers, floats, strings, booleans, lists, tuples, and dictionaries. The type of a variable can change dynamically based on the value assigned to it. Python provides built-in functions to determine the type of a variable, such as the \texttt{type()} function.

For example, consider the following code snippet:

\begin{Example}
\begin{lstlisting}[language=Python]
x = 5
print(type(x)) # Output: <class 'int'>

x = "Hello, World!"
print(type(x)) # Output: <class 'str'>
\end{lstlisting}
\end{Example}

In this code, the \texttt{type()} function is used to determine the type of the variable \texttt{x} before and after reassignment. The output shows that \texttt{x} changes from an integer (\texttt{int}) to a string (\texttt{str}).

Python also supports type hints, which allow you to specify the expected type of a variable. Although these hints are not enforced by the Python interpreter, they can be useful for documentation and code readability. Type hints can be added using the colon (\texttt{:}) followed by the type after the variable name.

\begin{Example}
Here's an example:

\begin{lstlisting}[language=Python]
x: int = 5
y: str = "Hello, World!"
\end{lstlisting}
\end{Example}

In this code, the type hints indicate that \texttt{x} should be an integer and \texttt{y} should be a string. While these hints are optional, they can help make your code more understandable and catch potential type-related errors early on.

\section{Python's Core Data Types}

Table \ref{tab:builtin-objects} previews Python's built-in object types and some of the syntax used to code their literals—that is, the expressions that generate these objects. Some of these types will probably seem familiar if you've used other languages; for instance, numbers and strings represent numeric and textual values, respectively, and files provide an interface for processing files stored on your computer.

\begin{table}[htbp]
    \centering
    \caption{Built-in objects preview}
    \label{tab:builtin-objects}
    \begin{tabular}{|l|l|}
    \hline
    \textbf{Object type} & \textbf{Example literals/creation} \\
    \hline
    Numbers & 1234, 3.1415, 3+4j, Decimal, Fraction \\
    Strings & 'spam', "guido's", b'a\x01c' \\
    Lists & [1, [2, 'three'], 4] \\
    Dictionaries & \{'food': 'spam', 'taste': 'yum'\} \\
    Tuples & (1, 'spam', 4, 'U') \\
    Files & myfile = open('eggs', 'r') \\
    Sets & set('abc'), {'a', 'b', 'c'} \\
    Other core types & Booleans, types, None \\
    Program unit types & Functions, modules, classes \\
    Implementation-related types & Compiled code, stack tracebacks \\
    \hline
    \end{tabular}
\end{table}

Table \ref{tab:builtin-objects} isn't really complete because everything we process in Python programs is a kind of object. For instance, when we perform text pattern matching in Python, we create pattern objects, and when we perform network scripting, we use socket objects. These other kinds of objects are generally created by importing and using modules and have behavior all their own.

As we'll see in later parts of the book, program units such as functions, modules, and classes are objects in Python too—they are created with statements and expressions such as \texttt{def}, \texttt{class}, \texttt{import}, and \texttt{lambda} and may be passed around scripts freely, stored within other objects, and so on. Python also provides a set of implementation-related types such as compiled code objects, which are generally of interest to tool builders more than application developers; these are also discussed in later parts of this text.

We usually refer to the other object types in Table \ref{tab:builtin-objects} as core data types because they are effectively built into the Python language—that is, there is specific expression syntax for generating most of them. For instance, when you run the following code:

\begin{lstlisting}[language=Python]
    'spam'
\end{lstlisting}

you are, technically speaking, running a literal expression that generates and returns a new string object. There is specific Python language syntax to make this object. Similarly, an expression wrapped in square brackets makes a list, one in curly braces makes a dictionary, and so on. Even though, as we'll see, there are no type declarations in Python, the syntax of the expressions you run determines the types of objects you create and use. In fact, object-generation expressions like those in Table \ref{tab:builtin-objects} are generally where types originate in the Python language.

Just as importantly, once you create an object, you bind its operation set for all time—you can perform only string operations on a string and list operations on a list. As you'll learn, Python is dynamically typed (it keeps track of types for you automatically instead of requiring declaration code), but it is also strongly typed (you can perform on an object only operations that are valid for its type).

Functionally, the object types in Table \ref{tab:builtin-objects} are more general and powerful than what you may be accustomed to. For instance, you'll find that lists and dictionaries alone are powerful data representation tools that obviate most of the work you do to support collections and searching in lower-level languages. In short, lists provide ordered collections of other objects, while dictionaries store objects by key; both lists and dictionaries may be nested, can grow and shrink on demand, and may contain objects of any type.

However, it's important to note that the table above represents only a subset of the object types available in Python. In the chapters that follow, we will delve into more general types and explore additional object types and concepts beyond those shown in Table \ref{tab:python-types}. This will give us a comprehensive understanding of the rich set of data structures and types that Python provides.

So, let's continue our journey and explore more advanced and powerful object types in the upcoming chapters.

\begin{table}[htbp]
\caption{Python Object Types}
\centering
\label{tab:python-types}

\lstset{
    basicstyle=\ttfamily,
    keywordstyle=\color{codeblue},
    stringstyle=\color{codered},
    commentstyle=\color{codegreen},
    showstringspaces=false,
    breaklines=true,
    frame=none,
    numbers=none,
    numberstyle=\small,
    captionpos=b
}

\begin{tabular}{|l|l|l|}
\hline
\textbf{Type} & \textbf{Description} & \textbf{Example} \\ \hline
\textbf{int} & Integers & \begin{lstlisting}[language=Python]
x = 5

\end{lstlisting} \\ \hline
\textbf{float} & Floating-point numbers & \begin{lstlisting}[language=Python]
y = 3.14

\end{lstlisting} \\ \hline
\textbf{complex} & Complex numbers & \begin{lstlisting}[language=Python]
z = 2 + 3j

\end{lstlisting} \\ \hline
\textbf{str} & Strings & \begin{lstlisting}[language=Python]
s = "Hello, World!"

\end{lstlisting} \\ \hline
\textbf{list} & Lists & \begin{lstlisting}[language=Python]
lst = [1, 2, 3]

\end{lstlisting} \\ \hline
\textbf{tuple} & Tuples & \begin{lstlisting}[language=Python]
tup = (4, 5, 6)

\end{lstlisting} \\ \hline
\textbf{dict} & Dictionaries & \begin{lstlisting}[language=Python]
person = {'name': 'John', 'age': 25}

\end{lstlisting} \\ \hline
\textbf{set} & Sets & \begin{lstlisting}[language=Python]
s = {1, 2, 3}

\end{lstlisting} \\ \hline
\textbf{bool} & Booleans & \begin{lstlisting}[language=Python]
a = True
b = False

\end{lstlisting} \\ \hline
\textbf{bytes} & Bytes & \begin{lstlisting}[language=Python]
bt = b'Hello'

\end{lstlisting} \\ \hline
\textbf{bytearray} & Bytearrays & \begin{lstlisting}[language=Python]
ba = bytearray(b'World')

\end{lstlisting} \\ \hline
\end{tabular}
\label{tab:python-types}
\end{table}


Python's flexibility in handling different variable types and its support for dynamic typing make it a versatile language for various programming tasks.


Python supports several data types, including:

\section{Numeric Types}
\textbf{Numeric Types:}
\begin{itemize}
\item \textbf{int} - integers, such as 1, 2, -5, etc.\\
\begin{Example}
The \texttt{int} type represents integers, which are whole numbers without a fractional part. For example:
\begin{lstlisting}[language=Python]
x = 5
print(x) # Output: 5
\end{lstlisting}
\end{Example}
\item \textbf{float} - floating-point numbers, such as 3.14, -2.5, etc.\\
\begin{Example}
The \texttt{float} type represents floating-point numbers, which have a decimal point. For example:
\begin{lstlisting}[language=Python]
y = 3.14
print(y) # Output: 3.14
\end{lstlisting}
\end{Example}
\item \textbf{complex} - complex numbers, represented as \textit{real + imaginary}, e.g., 2 + 3j.\\
\begin{Example}
The \texttt{complex} type represents complex numbers, which consist of a real part and an imaginary part. For example:
\begin{lstlisting}[language=Python]
z = 2 + 3j
print(z) # Output: (2+3j)
\end{lstlisting}
\end{Example}
\end{itemize}

If you've done any programming or scripting in the past, some of the object types in Table 4-1 will probably seem familiar. Even if you haven't, numbers are fairly straightforward. Python's core objects set includes the usual suspects: integers (numbers without a fractional part), floating-point numbers (roughly, numbers with a decimal point in them), and more exotic numeric types (complex numbers with imaginary parts, fixed-precision decimals, rational fractions with a numerator and denominator, and full-featured sets).

Although Python offers some fancier options, its basic number types are fundamental. Numbers in Python support the normal mathematical operations. For instance, the plus sign (+) performs addition, the star (*) is used for multiplication, and two stars (**) are used for exponentiation:

\begin{Example}
\begin{lstlisting}[language=Python]
print(123 + 222) # Integer addition
# Output: 345

print(1.5 * 4) # Floating-point multiplication
# Output: 6.0

print(2 ** 100) # 2 to the power 100
# Output: 1267650600228229401496703205376
\end{lstlisting}
\end{Example}

Python's integer type automatically provides extra precision for large numbers when needed. You can compute even extremely large numbers as integers in Python, but be cautious when working with very large results as they may have a significant number of digits:

\begin{Example}
\begin{lstlisting}[language=Python]
print(len(str(2 ** 1000000))) # How many digits in a really BIG number?
# Output: 301030
\end{lstlisting}
\end{Example}

When working with floating-point numbers, you may encounter a display issue due to the limited precision of floating-point representations:

\begin{Example}
\begin{lstlisting}[language=Python]
print(3.1415 * 2) # str: user-friendly
# Output: 6.283
\end{lstlisting}
\end{Example}

Python provides two ways to print an object: with full precision (as in the first result shown here) and in a user-friendly form (as in the second). The difference can matter when dealing with classes, but for now, if something looks odd, try displaying it with the \texttt{print} statement.

Python also includes various numeric modules that offer additional tools for numerical operations. For example, the \texttt{math} module provides advanced mathematical functions, and the \texttt{random} module allows random number generation:

\begin{Example}
\begin{lstlisting}[language=Python]
import math

print(math.pi)
# Output: 3.1415926535897931

print(math.sqrt(85))
# Output: 9.2195444572928871

import random

print(random.random())
# Output: 0.59268735266273953

print(random.choice([1, 2, 3, 4]))
# Output: 1
\end{lstlisting}
\end{Example}

Python also includes more exotic numeric objects such as complex numbers, fixed-precision decimals, rational numbers, sets, and Booleans. 


\section{Sequence Types}
\textbf{Sequence Types:}
\begin{itemize}
\item \textbf{str} - strings, a sequence of characters enclosed in single or double quotes, e.g., "Hello", 'World'.
\begin{Example}
\begin{lstlisting}
s = "Hello, World!"
print(s) # Output: Hello, World!
\end{lstlisting}
\end{Example}
Strings are immutable, meaning they cannot be modified after they are created. However, you can perform various operations on strings such as searching for substrings, replacing parts of the string, splitting the string into substrings, and more. String methods like \texttt{find()}, \texttt{replace()}, \texttt{split()}, and \texttt{upper()} can be used to manipulate and transform strings. In the Table \ref{tab:string-methods} all the methods usage are clearly shown.

\begin{table}[h]
\centering
\caption{String Methods}
\lstset{
    basicstyle=\ttfamily,
    keywordstyle=\color{codeblue},
    stringstyle=\color{codered},
    commentstyle=\color{codegreen},
    showstringspaces=false,
    breaklines=true,
    frame=none,
    numbers=none,
    numberstyle=\small,
    captionpos=b
}

\label{tab:string-methods}

\begin{tabular}{|l|l|p{7cm}|}
\hline
\textbf{Method} & \textbf{Example} & \textbf{Explanation} \\
\hline
\texttt{len()} & \texttt{len("Hello")} & Returns the length of the string. \\
\hline
\texttt{str.lower()} & \texttt{"Hello".lower()} & Converts all characters in the string to lowercase. \\
\hline
\texttt{str.upper()} & \texttt{"Hello".upper()} & Converts all characters in the string to uppercase. \\
\hline
\texttt{str.strip()} & \texttt{"  Hello  ".strip()} & Removes leading and trailing whitespace from the string. \\
\hline
\texttt{str.split()} & \texttt{"Hello,World".split(",")} & Splits the string into a list of substrings using the specified delimiter. \\
\hline
\texttt{str.find()} & \texttt{"Hello".find("l")} & Returns the index of the first occurrence of a substring in the string. \\
\hline
\texttt{str.replace()} & \texttt{"Hello".replace("H", "J")} & Replaces all occurrences of a substring with another substring. \\
\hline
\end{tabular}
\end{table}




\item \textbf{list} - ordered, mutable sequences of objects, enclosed in square brackets, e.g., [1, 2, 3]. If you have ever had a pleasure to meet the other definition, the curiosity you might have may be satisfied by looking at the chapter where we will be talking about the data structures more deeply. In the Table \ref{tab:list-methods} all the methods implemented in the list object are clearly shown. In Python, the simplicity of a language specification allow us not to remember about the precision of this specific data structure definition as it is for example implemented in the C++. 
\begin{Example}
\begin{lstlisting}
lst = [1, 2, 3]
print(lst) # Output: [1, 2, 3]
\end{lstlisting}
\end{Example}
Lists in Python are versatile and can contain objects of different types. They support operations like indexing, slicing, concatenation, and more. Additionally, lists have various methods such as \texttt{append()}, \texttt{pop()}, \texttt{sort()}, and \texttt{reverse()} that allow you to modify the list in-place. In the Table \ref{tab:list-methods} all the methods usage are clearly shown.
\begin{table}[h]
\centering
\lstset{
    basicstyle=\ttfamily,
    keywordstyle=\color{codeblue},
    stringstyle=\color{codered},
    commentstyle=\color{codegreen},
    showstringspaces=false,
    breaklines=true,
    frame=none,
    numbers=none,
    numberstyle=\small,
    captionpos=b
}
\caption{List Methods}
\label{tab:list-methods}
\begin{tabular}{|l|l|p{7cm}|}
\hline
\textbf{Method} & \textbf{Example} & \textbf{Explanation} \\
\hline
\texttt{len()} & \texttt{len([1, 2, 3])} & Returns the number of elements in the list. \\
\hline
\texttt{list.append()} & \texttt{[1, 2].append(3)} & Appends an element to the end of the list. \\
\hline
\texttt{list.extend()} & \texttt{[1, 2].extend([3, 4])} & Extends the list by appending elements from another list. \\
\hline
\texttt{list.insert()} & \texttt{[1, 3].insert(1, 2)} & Inserts an element at the specified index. \\
\hline
\texttt{list.remove()} & \texttt{[1, 2, 3].remove(2)} & Removes the first occurrence of an element from the list. \\
\hline
\texttt{list.pop()} & \texttt{[1, 2, 3].pop()} & Removes and returns the last element of the list. \\
\hline
\texttt{list.index()} & \texttt{[1, 2, 3].index(2)} & Returns the index of the first occurrence of an element in the list. \\
\hline
\texttt{list.sort()} & \texttt{[3, 1, 2].sort()} & Sorts the elements of the list in ascending order. \\
\hline
\texttt{list.reverse()} & \texttt{[1, 2, 3].reverse()} & Reverses the order of the elements in the list. \\
\hline
\end{tabular}
\end{table}


\item \textbf{tuple} - ordered, immutable sequences of objects, enclosed in parentheses, e.g., (4, 5, 6).
\begin{Example}
\begin{lstlisting}
tup = (4, 5, 6)
print(tup) # Output: (4, 5, 6)
\end{lstlisting}
\end{Example}

Tuples are similar to lists, but they are immutable, meaning their elements cannot be changed after creation. This makes tuples useful for representing collections of related values that should not be modified. In contrast, the tuple type in C\# is mutable and allows elements to be modified.

Tuples in Python support indexing and slicing, just like lists and strings. You can access individual elements of a tuple using square brackets and the element's index. Additionally, tuples have several methods that allow you to manipulate them, such as \texttt{len()}, \texttt{index()}, and \texttt{count()}.

In Table \ref{tab:tuple-methods}, you can find examples and explanations of some common methods used for tuple manipulation.
\end{itemize}

\begin{table}[h]
\centering
\caption{Tuple Methods}
\lstset{
    basicstyle=\ttfamily,
    keywordstyle=\color{codeblue},
    stringstyle=\color{codered},
    commentstyle=\color{codegreen},
    showstringspaces=false,
    breaklines=true,
    frame=none,
    numbers=none,
    numberstyle=\small,
    captionpos=b
}
\label{tab:tuple-methods}
\begin{tabular}{|l|l|p{7cm}|}
\hline
\textbf{Method} & \textbf{Example} & \textbf{Explanation} \\
\hline
\texttt{len()} & \texttt{len((4, 5, 6))} & Returns the number of elements in the tuple. \\
\hline
\texttt{tuple.index()} & \texttt{(4, 5, 6).index(5)} & Returns the index of the first occurrence of an element in the tuple. \\
\hline
\texttt{tuple.count()} & \texttt{(4, 4, 5, 6).count(4)} & Returns the number of occurrences of an element in the tuple. \\
\hline
\end{tabular}
\end{table}

\section{Mapping Type}
\textbf{Mapping Type:}
\begin{itemize}
\item \textbf{dict} - dictionaries, unordered collections of key-value pairs, enclosed in curly braces, e.g., {'name': 'John', 'age': 25}.
\begin{Example}
\begin{lstlisting}
person = {'name': 'John', 'age': 25}
print(person) # Output: {'name': 'John', 'age': 25}
\end{lstlisting}
\end{Example}
Dictionaries are useful for storing and retrieving data by using unique keys as identifiers. Each key in a dictionary is associated with a value, and you can access values by their corresponding keys. Dictionary keys must be immutable types such as strings or numbers. Dictionaries support operations like adding new key-value pairs, accessing values by keys, modifying values, and more.
\end{itemize}

In addition to the basic sequence operations, such as indexing and slicing, each sequence type has specific methods associated with it. For example, string methods like \texttt{find()} and \texttt{replace()} allow you to search for substrings or replace parts of a string. Here are a few examples of string methods:

\begin{itemize}
\item \texttt{find(substring)} - Returns the index of the first occurrence of the substring in the string, or -1 if the substring is not found.
\begin{Example}
\begin{lstlisting}
s = "Hello, World!"
index = s.find("World")
print(index) # Output: 7
\end{lstlisting}
\end{Example}

\item \texttt{replace(old, new)} - Returns a new string where all occurrences of the old substring are replaced with the new substring.
\begin{Example}
\begin{lstlisting}
s = "Hello, World!"
new_s = s.replace("World", "Python")
print(new_s) # Output: Hello, Python!
\end{lstlisting}
\end{Example}

\item \texttt{split(separator)} - Splits the string into a list of substrings at each occurrence of the separator.
\begin{Example}
\begin{lstlisting}
s = "Hello, World!"
words = s.split(", ")
print(words) # Output: ['Hello', 'World!']
\end{lstlisting}
\end{Example}

\item \texttt{upper()} - Returns a new string with all characters converted to uppercase.
\begin{Example}
\begin{lstlisting}
s = "Hello, World!"
upper_s = s.upper()
print(upper_s) # Output: HELLO, WORLD!
\end{lstlisting}
\end{Example}
\end{itemize}

\begin{table}[h]
\centering
\caption{Dictionary Methods}
\lstset{
    basicstyle=\ttfamily,
    keywordstyle=\color{codeblue},
    stringstyle=\color{codered},
    commentstyle=\color{codegreen},
    showstringspaces=false,
    breaklines=true,
    frame=none,
    numbers=none,
    numberstyle=\small,
    captionpos=b
}
\label{tab:dict-methods}
\begin{tabular}{|p{3cm}|p{6cm}|p{5.2cm}|}
\hline
\textbf{Method} & \textbf{Example} & \textbf{Explanation} \\
\hline
\texttt{len()} & \texttt{len(\{'name': 'John', 'age': 25\})} & Returns the number of key-value pairs in the dictionary. \\
\hline
\texttt{dict.keys()} & \texttt{\{'name': 'John', 'age': 25\}.keys()} & Returns a list of all keys in the dictionary. \\
\hline
\texttt{dict.values()} & \texttt{\{'name': 'John', 'age': 25\}.values()} & Returns a list of all values in the dictionary. \\
\hline
\texttt{dict.get()} & \texttt{\{'name': 'John', 'age': 25\}.get('name')} & Returns the value associated with the specified key, or a default value if the key is not found. \\
\hline
\texttt{dict.pop()} & \texttt{\{'name': 'John', 'age': 25\}.pop('age')} & Removes and returns the value associated with the specified key. \\
\hline
\texttt{dict.update()} & \texttt{\{'name': 'John'\}.update(\{'age': 25\})} & Updates the dictionary with the key-value pairs from another dictionary. \\
\hline
\end{tabular}
\end{table}

Similarly, lists have methods like \texttt{append()}, \texttt{pop()}, \texttt{sort()}, and \texttt{reverse()}. Dictionaries have methods for adding, accessing, and modifying key-value pairs, such as \texttt{keys()}, \texttt{values()}, and \texttt{update()}.

These methods provide additional functionality and flexibility when working with different sequence types in Python. For more details on available methods and their usage, you can refer to Python's standard library documentation or use the \texttt{dir()} and \texttt{help()} functions to explore the available attributes and get help on specific methods of sequence types.

 Table \ref{tab:dict-methods}, you can find the usage and explanations of some common methods used for dictionaries manipulation implemented in Python.
\end{itemize}


\section{Set Types}
\textbf{Set Types:}
\begin{itemize}
\item \textbf{set} - unordered collections of unique elements, enclosed in curly braces, e.g., {1, 2, 3}.
\begin{Example}
\begin{lstlisting}
s = {1, 2, 3}
print(s) # Output: {1, 2, 3}
\end{lstlisting}
\end{Example}

\item \textbf{frozenset} - immutable sets, enclosed in parentheses, e.g., frozenset({4, 5, 6}).
\begin{Example}
\begin{lstlisting}
fs = frozenset({4, 5, 6})
print(fs) # Output: frozenset({4, 5, 6})
\end{lstlisting}
\end{Example}
\end{itemize}

Sets in Python are unordered collections of unique elements. They are represented by curly braces ({}) and do not allow duplicate values. Sets are useful for operations like membership testing, removing duplicates from a sequence, and mathematical set operations such as union, intersection, and difference.

Here's a table \ref{tab:set-methods} showcasing some common methods used for set manipulation:

\begin{table}[h]
\centering
\caption{Set Methods}
\lstset{
    basicstyle=\ttfamily,
    keywordstyle=\color{codeblue},
    stringstyle=\color{codered},
    commentstyle=\color{codegreen},
    showstringspaces=false,
    breaklines=true,
    frame=none,
    numbers=none,
    numberstyle=\small,
    captionpos=b
}
\label{tab:set-methods}
\begin{tabular}{|p{4cm}|p{5cm}|p{6.2cm}|}
\hline
\textbf{Method} & \textbf{Example} & \textbf{Explanation} \\
\hline
\texttt{len()} & \texttt{len(\{1, 2, 3\})} & Returns the number of elements in the set. \\
\hline
\texttt{set.add()} & \texttt{\{1, 2\}.add(3)} & Adds an element to the set. \\
\hline
\texttt{set.remove()} & \texttt{\{1, 2, 3\}.remove(2)} & Removes an element from the set. \\
\hline
\texttt{set.discard()} & \texttt{\{1, 2, 3\}.discard(4)} & Removes an element from the set if it exists, without raising an error if it doesn't. \\
\hline
\texttt{set.pop()} & \texttt{\{1, 2, 3\}.pop()} & Removes and returns an arbitrary element from the set. \\
\hline
\texttt{set.union()} & \texttt{\{1, 2\}.union(\{2, 3\})} & Returns a new set with all unique elements from both sets. \\
\hline
\texttt{set.intersection()} & \texttt{\{1, 2\}.intersection(\{2, 3\})} & Returns a new set with common elements of both sets. \\
\hline
\texttt{set.difference()} & \texttt{\{1, 2, 3\}.difference(\{2, 3, 4\})} & Returns a new set with elements in the set that are not in the given set. \\
\hline
\texttt{set.clear()} & \texttt{\{1, 2, 3\}.clear()} & Removes all elements from the set. \\
\hline
\end{tabular}
\end{table}



\section{Boolean Type}
\textbf{Boolean Type:}
\begin{itemize}
\item \textbf{bool} - boolean values, either \textit{True} or \textit{False}.
\begin{Example}
\begin{lstlisting}
a = True
b = False
print(a) # Output: True
print(b) # Output: False
\end{lstlisting}
\end{Example}
\end{itemize}

The boolean type in Python represents logical values, which can be either \textit{True} or \textit{False}. Booleans are often used in decision-making and control flow statements to determine the execution path based on conditions. 

In Python, boolean values can be assigned to variables, used in expressions, and compared using logical operators such as \texttt{and}, \texttt{or}, and \texttt{not}. The boolean type is also the result of comparison operations, such as equality (\texttt{==}), inequality (\texttt{!=}), greater than (\texttt{>}), less than (\texttt{<}), etc.

Here's an example that demonstrates the usage of boolean values in Python:

\begin{lstlisting}
x = 10
y = 5
is_greater = x > y
print(is_greater)  # Output: True
\end{lstlisting}

In this example, the boolean variable \texttt{is\_greater} is assigned the value \texttt{True} because the condition \texttt{x > y} is true.

Boolean values play a crucial role in control flow statements like \texttt{if}, \texttt{while}, and \texttt{for} loops, as they determine the execution of specific code blocks based on the evaluation of conditions.

Understanding boolean values and their usage is fundamental in programming, as it allows you to create conditional logic and make decisions based on different conditions. Now it is a hight time to tale a brief look how the boolean type may be explained using the mathematical logic basics and the elements of the set theory.


Mathematical logic, as the foundation of mathematics, is about symbolic abstraction. One way to analyze and understand a proposition is by utilizing mathematical symbols and the rules of logic.

Consider two propositions, \(A\) and \(B\). We can combine these propositions using logical operators to form complex propositions. The logical operators often used are 'AND' (\(\land\)), 'OR' (\(\lor\)), and 'NOT' (\(\neg\)).

The 'AND' operator, denoted as \(A \land B\), results in true only if both \(A\) and \(B\) are true. The 'OR' operator, denoted as \(A \lor B\), results in true if either \(A\) or \(B\) (or both) are true. The 'NOT' operator is a unary operator that negates the truth value of its operand. If \(A\) is true, then \(\neg A\) is false, and vice versa.

The truth values of these logical operations can be represented by truth tables. A truth table for a logical operation lists the possible truth values of the operation for each possible combination of truth values of its operands. 

For example, for the logical 'AND' operator, we have the following truth table:

\[
\begin{array}{|c|c|c|}
\hline
A & B & A \land B \\
\hline
T & T & T \\
T & F & F \\
F & T & F \\
F & F & F \\
\hline
\end{array}
\]

For the logical 'OR' operator, we have the following truth table:

\[
\begin{array}{|c|c|c|}
\hline
A & B & A \lor B \\
\hline
T & T & T \\
T & F & T \\
F & T & T \\
F & F & F \\
\hline
\end{array}
\]

Understanding these basic operations and truth tables is essential for the study of mathematical logic, and it serves as the basis for more advanced concepts in the field, such as implication, biconditional, contradiction, and equivalence.




\section{Binary Types}
\textbf{Binary Types:}
\begin{itemize}
\item \textbf{bytes} - sequences of integers in the range 0-255, enclosed in parentheses with a \textit{b} prefix, e.g., b'Hello'.
\begin{Example}
\begin{lstlisting}
bt = b'Hello'
print(bt) # Output: b'Hello'
\end{lstlisting}
\end{Example}
\item \textbf{bytearray} - mutable sequences of integers in the range 0-255, enclosed in parentheses with a \textit{bytearray} prefix, e.g., bytearray(b'World').
\begin{Example}
\begin{lstlisting}
ba = bytearray(b'World')
print(ba) # Output: bytearray(b'World')
\end{lstlisting}
\end{Example}
\end{itemize}

Binary types in Python, such as \texttt{bytes} and \texttt{bytearray}, are used to represent sequences of integers in the range 0-255. These types are often used to handle binary data, such as file I/O, network communication, and cryptographic operations.

\texttt{bytes} objects are immutable, meaning they cannot be modified after creation. They are represented by a sequence of integers enclosed in parentheses with a \textit{b} prefix, e.g., \texttt{b'Hello'}. You can access individual bytes within a \texttt{bytes} object using indexing.

\texttt{bytearray} objects, on the other hand, are mutable and allow in-place modifications. They are represented by a sequence of integers enclosed in parentheses with a \textit{bytearray} prefix, e.g., \texttt{bytearray(b'World')}. You can modify individual bytes within a \texttt{bytearray} object using indexing.

Here's a table \ref{tab:binary-operations} showcasing some common operations and functions used with binary types:

\begin{table}[h]
\centering
\caption{Binary Operations and Functions (Continued)}
\lstset{
    basicstyle=\ttfamily,
    keywordstyle=\color{codeblue},
    stringstyle=\color{codered},
    commentstyle=\color{codegreen},
    showstringspaces=false,
    breaklines=true,
    frame=none,
    numbers=none,
    numberstyle=\small,
    captionpos=b
}
\label{tab:binary-operations}
\begin{tabular}{|l|l|p{7cm}|}
\hline
\textbf{Operation/Function} & \textbf{Example} & \textbf{Explanation} \\
\hline
Indexing & \texttt{bt[0]} & Accesses the byte at the specified index in the \texttt{bytes} object. \\
\hline
Slicing & \texttt{ba[1:3]} & Returns a new \texttt{bytearray} object containing a slice of bytes from the original object. \\
\hline
Length & \texttt{len(bt)} & Returns the number of bytes in the \texttt{bytes} object. \\
\hline
Conversion & \texttt{bytes([65, 66, 67])} & Creates a \texttt{bytes} object from a list of integers representing ASCII values. \\
\hline
\texttt{hex()} & \texttt{ba.hex()} & Returns a hexadecimal representation of the \texttt{bytearray} object. \\
\hline
\texttt{decode()} & \texttt{bt.decode()} & Decodes the \texttt{bytes} object into a string using a specified encoding (e.g., UTF-8). \\
\hline
\end{tabular}
\end{table}


Each data type in Python has its own characteristics and methods associated with it, allowing you to perform various operations and manipulations. Python also provides built-in functions to convert between different data types.

It's important to note that variables in Python are dynamically typed, meaning that you can assign values of different types to the same variable. Python automatically adjusts the type of the variable based on the assigned value. This flexibility allows for easy and convenient programming.


\section{Problems and Solutions}
\begin{enumerate}
    \item  Write a function to check if a given variable is of a certain type.

    \textbf{Solution:}
    \begin{lstlisting}
    def check_type(var, type):
        return isinstance(var, type)
    \end{lstlisting}
    
    \item  Convert a float to an integer without using built-in functions.

    \textbf{Solution:}
    \begin{lstlisting}
    def float_to_int(f):
        return int(f // 1)
    \end{lstlisting}

    \item  Swap two variables without using a temporary variable.

    \textbf{Solution:}
    \begin{lstlisting}
    def swap_vars(a, b):
        a, b = b, a
        return a, b
    \end{lstlisting}

    \item  Write a function to compute the factorial of a number.

    \textbf{Solution:}
    \begin{lstlisting}
    def factorial(n):
        return 1 if (n==1 or n==0) else n * factorial(n - 1)
    \end{lstlisting}

    \item  Convert a decimal number to binary without using built-in functions.

    \textbf{Solution:}
    \begin{lstlisting}
    def decimal_to_binary(n):
        return bin(n).replace("0b", "")
    \end{lstlisting}

    \item  Write a function to reverse a string.

    \textbf{Solution:}
    \begin{lstlisting}
    def reverse_string(s):
        return s[::-1]
    \end{lstlisting}

    \item  Write a function to count the occurrences of a character in a string.

    \textbf{Solution:}
    \begin{lstlisting}
    def count_char(s, c):
        return s.count(c)
    \end{lstlisting}

    \item  Implement a function to convert a list of integers into a single integer.

    \textbf{Solution:}
    \begin{lstlisting}
    def list_to_int(l):
        return int("".join(map(str, l)))
    \end{lstlisting}

    \item  Write a function to check if a string is a palindrome.

    \textbf{Solution:}
    \begin{lstlisting}
    def is_palindrome(s):
        return s == s[::-1]
    \end{lstlisting}

    \item  Implement a function to calculate the nth Fibonacci number.

    \textbf{Solution:}
    \begin{lstlisting}
    def fibonacci(n):
        if n<=0:
            return "Input should be positive integer"
        elif n==1:
            return 0
        elif n==2:
            return 1
        else:
            a, b = 0, 1
            for i in range(2, n):
                a, b = b, a + b
            return b
    \end{lstlisting}
    
    \item  Write a function to check if a list is empty or not.

    \textbf{Solution:}
    \begin{lstlisting}
    def is_empty(lst):
        return not lst
    \end{lstlisting}

    \item  Write a function to clone or copy a list.

    \textbf{Solution:}
    \begin{lstlisting}
    def copy_list(lst):
        return lst[:]
    \end{lstlisting}

    \item } Write a function to get the frequency of a particular element in a list.

    \textbf{Solution:}
    \begin{lstlisting}
    def count_element(lst, elem):
        return lst.count(elem)
    \end{lstlisting}

    \item Write a function to find the largest number in a list.

    \textbf{Solution:}
    \begin{lstlisting}
    def max_of_list(lst):
        return max(lst)
    \end{lstlisting}

    \item Write a function to print all unique values in a list.

    \textbf{Solution:}
    \begin{lstlisting}
    def unique_elements(lst):
        return list(set(lst))
    \end{lstlisting}

    \item  Write a function to check if a list is sorted or not.

    \textbf{Solution:}
    \begin{lstlisting}
    def is_sorted(lst):
        return lst == sorted(lst)
    \end{lstlisting}

    \item  Write a function to remove duplicates from a list.

    \textbf{Solution:}
    \begin{lstlisting}
    def remove_duplicates(lst):
        return list(set(lst))
    \end{lstlisting}

    \item Write a function to find the second largest number in a list.

    \textbf{Solution:}
    \begin{lstlisting}
    def second_largest(lst):
        return sorted(lst)[-2]
    \end{lstlisting}

    \item  Write a function to find the intersection of two lists.

    \textbf{Solution:}
    \begin{lstlisting}
    def intersect_lists(lst1, lst2):
        return list(set(lst1) & set(lst2))
    \end{lstlisting}

    \item  Write a function to concatenate two lists in the following manner: if `list1 = ['a', 'b']` and `list2 = ['1', '2']`, the result should be `['a1', 'b2']`.

    \textbf{Solution:}
    \begin{lstlisting}
    def concatenate_lists(list1, list2):
        return [i + j for i, j in zip(list1, list2)]
    \end{lstlisting}
    
    \item  Write a function to reverse a list.

    \textbf{Solution:}
    \begin{lstlisting}
    def reverse_list(lst):
        return lst[::-1]
    \end{lstlisting}

    \item  Write a function that flattens a nested list.

    \textbf{Solution:}
    \begin{lstlisting}
    def flatten_list(nested_lst):
        return [elem for sublist in nested_lst for elem in sublist]
    \end{lstlisting}

    \item  Write a function that takes two lists and returns True if they have at least one common member.

    \textbf{Solution:}
    \begin{lstlisting}
    def common_member(lst1, lst2):
        return any(elem in lst1 for elem in lst2)
    \end{lstlisting}

    \item  Write a function to convert a tuple to a string.

    \textbf{Solution:}
    \begin{lstlisting}
    def tuple_to_string(tup):
        return ''.join(tup)
    \end{lstlisting}

    \item  Write a function to print a tuple with string formatting.

    \textbf{Solution:}
    \begin{lstlisting}
    def print_tuple(tup):
        print("This is your tuple: %s" % (tup,))
    \end{lstlisting}

    \item  Write a function to replace the last value of tuples in a list.

    \textbf{Solution:}
    \begin{lstlisting}
    def replace_last_value_in_tuples(lst, value):
        return [(tup[:-1] + (value,)) for tup in lst]
    \end{lstlisting}

    \item  Write a function to sort a list of tuples using the second element.

    \textbf{Solution:}
    \begin{lstlisting}
    def sort_tuples(lst):
        return sorted(lst, key=lambda x: x[1])
    \end{lstlisting}

    \item  Write a function to remove an empty tuple(s) from a list of tuples.

    \textbf{Solution:}
    \begin{lstlisting}
    def remove_empty_tuples(lst):
        return [tup for tup in lst if tup]
    \end{lstlisting}

    \item  Write a function to find the index of an item of a tuple.

    \textbf{Solution:}
    \begin{lstlisting}
    def index_of_tuple(tup, item):
        return tup.index(item)
    \end{lstlisting}

    \item Write a function to find the length of a tuple.

    \textbf{Solution:}
    \begin{lstlisting}
    def length_of_tuple(tup):
        return len(tup)
    \end{lstlisting}
    
    \item  Write a function to add a key-value pair to a dictionary.

    \textbf{Solution:}
    \begin{lstlisting}
    def add_key_value(dictionary, key, value):
        dictionary[key] = value
        return dictionary
    \end{lstlisting}

    \item  Write a function to concatenate two dictionaries.

    \textbf{Solution:}
    \begin{lstlisting}
    def concat_dictionaries(dict1, dict2):
        dict1.update(dict2)
        return dict1
    \end{lstlisting}

    \item  Write a function to check if a given key exists in a dictionary.

    \textbf{Solution:}
    \begin{lstlisting}
    def check_key(dictionary, key):
        return key in dictionary
    \end{lstlisting}

    \item  Write a function to generate and print a dictionary that contains numbers (between 1 and n) in the form (x, x*x).

    \textbf{Solution:}
    \begin{lstlisting}
    def square_dictionary(n):
        return {i: i*i for i in range(1, n+1)}
    \end{lstlisting}

    \item  Write a function to sum all the items in a dictionary.

    \textbf{Solution:}
    \begin{lstlisting}
    def sum_dictionary(dictionary):
        return sum(dictionary.values())
    \end{lstlisting}

    \item  Write a function to multiply all the items in a dictionary.

    \textbf{Solution:}
    \begin{lstlisting}
    def multiply_dictionary(dictionary):
        result = 1
        for value in dictionary.values():
            result *= value
        return result
    \end{lstlisting}

    \item  Write a function to remove a key from a dictionary.

    \textbf{Solution:}
    \begin{lstlisting}
    def remove_key(dictionary, key):
        if key in dictionary:
            del dictionary[key]
        return dictionary
    \end{lstlisting}

    \item  Write a function to map two lists into a dictionary.

    \textbf{Solution:}
    \begin{lstlisting}
    def map_lists_to_dict(keys, values):
        return dict(zip(keys, values))
    \end{lstlisting}

    \item Write a function to sort a dictionary by key.

    \textbf{Solution:}
    \begin{lstlisting}
    def sort_dict_by_key(dictionary):
        return {k: dictionary[k] for k in sorted(dictionary)}
    \end{lstlisting}

    \item  Write a function to get the maximum and minimum value in a dictionary.

    \textbf{Solution:}
    \begin{lstlisting}
    def max_and_min(dictionary):
        max_value = max(dictionary.values())
        min_value = min(dictionary.values())
        return max_value, min_value
    \end{lstlisting}
\end{enumerate}






\newpage
\chapter{Operators}
Python includes a variety of operators for performing operations on values. These include arithmetic operators, comparison operators, assignment operators, logical operators, and more.

\section{Arithmetic Operators}

Python includes arithmetic operators for performing mathematical operations on values. Here are some commonly used arithmetic operators:

\begin{itemize}
\item \textbf{$+$ (Addition)}: Adds two values.
\item \textbf{$-$ (Subtraction)}: Subtracts one value from another.
\item \textbf{$*$ (Multiplication)}: Multiplies two values.
\item \textbf{$/$ (Division)}: Divides one value by another.
\item \textbf{$//$ (Floor Division)}: Performs division and rounds the result down to the nearest whole number.
\item \textbf{\% (Modulus)}: Returns the remainder after division.
\item \textbf{$**$ (Exponentiation)}: Raises a value to the power of another value.
\end{itemize}

Here are some examples of using arithmetic operators:

\begin{Example}
\begin{lstlisting}[language=Python]
x = 5 + 3 # Addition: x = 8
y = 10 - 4 # Subtraction: y = 6
z = 3 * 2 # Multiplication: z = 6
w = 12 / 4 # Division: w = 3.0
v = 13 // 5 # Floor Division: v = 2
r = 15 % 4 # Modulus: r = 3
s = 2 \** 4 # Exponentiation: s = 16
\end{lstlisting}
\end{Example}

In these examples, the arithmetic operators perform the specified operations on the values and assign the results to the respective variables.

\section{Mathematical Functions}

In addition to the basic arithmetic operators, Python also provides built-in mathematical functions that allow you to perform more complex mathematical calculations. These functions are part of the math module, which needs to be imported before use.

Here are some commonly used mathematical functions in Python:

\begin{itemize}
\item \texttt{abs(x)}: Returns the absolute value of \texttt{x}.
\item \texttt{round(x, n)}: Rounds \texttt{x} to \texttt{n} decimal places. If \texttt{n} is not specified, it rounds to the nearest integer.
\item \texttt{max(iterable)}: Returns the largest value in the \texttt{iterable}.
\item \texttt{min(iterable)}: Returns the smallest value in the \texttt{iterable}.
\item \texttt{pow(x, y)}: Returns \texttt{x} raised to the power of \texttt{y}.
\item \texttt{sqrt(x)}: Returns the square root of \texttt{x}.
\item \texttt{sin(x)}: Returns the sine of \texttt{x} (in radians).
\item \texttt{cos(x)}: Returns the cosine of \texttt{x} (in radians).
\item \texttt{tan(x)}: Returns the tangent of \texttt{x} (in radians).
\item \texttt{log(x)}: Returns the natural logarithm (base \textit{e}) of \texttt{x}.
\item \texttt{log10(x)}: Returns the base-10 logarithm of \texttt{x}.
\end{itemize}

Here are some examples of using mathematical functions:

\begin{Example}
\begin{lstlisting}[language=Python]
import math

abs_value = abs(-5) # abs_value = 5
rounded = round(3.14159, 2) # rounded = 3.14
largest = max([4, 9, 2, 7]) # largest = 9
smallest = min([4, 9, 2, 7]) # smallest = 2
power = pow(2, 3) # power = 8
sqrt_value = math.sqrt(16) # sqrt_value = 4.0
sine = math.sin(math.pi/2) # sine = 1.0
cosine = math.cos(math.pi) # cosine = -1.0
tangent = math.tan(math.pi/4) # tangent = 1.0
natural_log = math.log(10) # natural_log = 2.302585092994046
log_10 = math.log10(100) # log_10 = 2.0
\end{lstlisting}
\end{Example}

In these examples, the mathematical functions are used to perform various calculations, such as finding the absolute value, rounding to a specific decimal place, finding the maximum and minimum values, raising a number to a power, calculating trigonometric functions, and logarithmic functions.

Note that the math module is imported using the \texttt{import} statement to access these mathematical functions.

\section{Comparison Operators}

Comparison operators are used to compare two values and return a boolean result (True or False) based on the comparison. Here are some commonly used comparison operators:

\begin{itemize}
\item \textbf{$>$ (Greater than)}: Returns True if the left value is greater than the right value.
\item \textbf{$<$ (Less than)}: Returns True if the left value is less than the right value.
\item \textbf{$>=$ (Greater than or equal to)}: Returns True if the left value is greater than or equal to the right value.
\item \textbf{$<=$ (Less than or equal to)}: Returns True if the left value is less than or equal to the right value.
\item \textbf{$==$ (Equal to)}: Returns True if the left value is equal to the right value.
\item \textbf{$!=$ (Not equal to)}: Returns True if the left value is not equal to the right value.
\end{itemize}

Here are some examples of using comparison operators:

\begin{Example}
\begin{lstlisting}[language=Python]
x = 5 > 3 # Greater than: x = True
y = 10 < 4 # Less than: y = False
z = 3 >= 2 # Greater than or equal to: z = True
w = 12 <= 4 # Less than or equal to: w = False
v = 5 == 5 # Equal to: v = True
r = 15 != 4 # Not equal to: r = True
\end{lstlisting}
\end{Example}

In these examples, the comparison operators compare the values and return the boolean results based on the comparison.

\section{Assignment Operators}

Assignment operators are used to assign values to variables. The basic assignment operator in Python is $=$. It assigns the value on the right side to the variable on the left side.

Here are some examples of using assignment operators:

\begin{Example}
\begin{lstlisting}[language=Python]
x = 5 # Assigns the value 5 to the variable x
y = 2 # Assigns the value 2 to the variable y
\end{lstlisting}
\end{Example}

Python also provides compound assignment operators that combine an arithmetic operation with assignment. These include $+=$, $-=$, $*=$, $/=$, and $%=$ among others.

\section{Set Operations}

Python provides several set operations that allow you to manipulate and perform computations on sets. Here are some commonly used set operations:

\begin{itemize}
\item \textbf{Union ($\cup$)}: Returns a new set containing all the unique elements from both sets.
\item \textbf{Intersection ($\cap$)}: Returns a new set containing the common elements between both sets.
\item \textbf{Difference ($-$)}: Returns a new set containing the elements that are in the first set but not in the second set.
\item \textbf{Symmetric Difference ($\oplus$)}: Returns a new set containing the elements that are in either of the sets, but not in both.
\item \textbf{Subset ($\subset$)}: Checks if one set is a subset of another set.
\item \textbf{Superset ($\supset$)}: Checks if one set is a superset of another set.
\end{itemize}

Here's an example of using set operations in Python:

\begin{Example}
\begin{lstlisting}[language=Python]
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}

union_set = set1 | set2 # Union: union_set = {1, 2, 3, 4, 5, 6}
intersection_set = set1 & set2 # Intersection: intersection_set = {3, 4}
difference_set = set1 - set2 # Difference: difference_set = {1, 2}
symmetric_difference_set = set1 ^ set2 # Symmetric Difference: symmetric_difference_set = {1, 2, 5, 6}
is_subset = set1.issubset(set2) # Subset: is_subset = False
is_superset = set1.issuperset(set2) # Superset: is_superset = False
\end{lstlisting}
\end{Example}

\section{Logical Operators}

Logical operators are used to combine and manipulate boolean values (\texttt{True} and \texttt{False}). Python includes three logical operators: \texttt{and}, \texttt{or}, and \texttt{not}.

Here's an example that demonstrates the usage of logical operators:

\begin{Example}
\begin{lstlisting}[language=Python]
x = 5
y = 10

print(x > 0 and y < 100) # Output: True
print(x > 0 or y < 100) # Output: True
print(not x > 0) # Output: False
\end{lstlisting}
\end{Example}

In this example, the \texttt{and} operator returns \texttt{True} if both the expressions on its left and right side are \texttt{True}. The \texttt{or} operator returns \texttt{True} if at least one of the expressions on its left or right side is \texttt{True}. The \texttt{not} operator negates the boolean value.


\section{Bitwise Operators}

Bitwise operators in Python are used to perform bitwise operations on individual bits of integer values. These operators treat the operands as sequences of bits and perform operations on corresponding bits.

Here are the bitwise operators available in Python:

\begin{itemize}
\item \textbf{AND (&)}: Performs a bitwise AND operation on the corresponding bits of two operands.
\item \textbf{OR ($|$)}: Performs a bitwise OR operation on the corresponding bits of two operands.
\item \textbf{XOR ($\hat{}$)}: Performs a bitwise XOR (exclusive OR) operation on the corresponding bits of two operands.
\item \textbf{NOT ($\sim$)}: Performs a bitwise NOT operation, which flips the bits of the operand.
\item \textbf{Left Shift ($<<$)}: Shifts the bits of the left operand to the left by the number of positions specified by the right operand.
\item \textbf{Right Shift ($>>$)}: Shifts the bits of the left operand to the right by the number of positions specified by the right operand.
\end{itemize}

Here's an example of using bitwise operators in Python:

\begin{Example}
\begin{lstlisting}[language=Python]
a = 10 # Binary: 1010
b = 6 # Binary: 0110

bitwise_and = a & b # Bitwise AND: 2 (Binary: 0010)
bitwise_or = a | b # Bitwise OR: 14 (Binary: 1110)
bitwise_xor = a ^ b # Bitwise XOR: 12 (Binary: 1100)
bitwise_not_a = ~a # Bitwise NOT of a: -11 (Binary: 11111111111111111111111111110101)
left_shift = a << 2 # Left shift a by 2 positions: 40 (Binary: 101000)
right_shift = a >> 1 # Right shift a by 1 position: 5 (Binary: 101)
\end{lstlisting}
\end{Example}

In this example, the bitwise operators are applied to the variables \texttt{a} and \texttt{b}, resulting in new values that represent the bitwise operations performed on the individual bits.

Bitwise operators are useful in scenarios where you need to manipulate or extract specific bits from integers, perform binary flag operations, or optimize certain algorithms by taking advantage of bitwise operations at the binary level.

\section{Number Base Conversion Functions}

In Python, you can convert numbers between different bases, such as binary, octal, decimal, and hexadecimal. The built-in functions bin(), oct(), hex(), and int() allow you to perform number base conversions. Here's how you can use these functions:

\begin{itemize}
\item \textbf{Binary to Decimal}: Use the int() function with the base parameter set to 2 to convert a binary number to decimal.
\begin{Example}
\begin{lstlisting}[language=Python]
binary_num = '10101'
decimal_num = int(binary_num, 2)
print(decimal_num) # Output: 21
\end{lstlisting}
\end{Example}

\item \textbf{Decimal to Binary}: Use the bin() function to convert a decimal number to binary.
\begin{Example}
\begin{lstlisting}[language=Python]
decimal_num = 21
binary_num = bin(decimal_num)
print(binary_num) # Output: '0b10101'
\end{lstlisting}
\end{Example}

\item \textbf{Decimal to Octal}: Use the oct() function to convert a decimal number to octal.
\begin{Example}
\begin{lstlisting}[language=Python]
decimal_num = 21
octal_num = oct(decimal_num)
print(octal_num) # Output: '0o25'
\end{lstlisting}
\end{Example}

\item \textbf{Decimal to Hexadecimal}: Use the hex() function to convert a decimal number to hexadecimal.
\begin{Example}
\begin{lstlisting}[language=Python]
decimal_num = 21
hexadecimal_num = hex(decimal_num)
print(hexadecimal_num) # Output: '0x15'
\end{lstlisting}
\end{Example}

\item \textbf{Hexadecimal to Decimal}: Use the int() function with the base parameter set to 16 to convert a hexadecimal number to decimal.
\begin{Example}
\begin{lstlisting}[language=Python]
hexadecimal_num = '15'
decimal_num = int(hexadecimal_num, 16)
print(decimal_num) # Output: 21
\end{lstlisting}
\end{Example}
\end{itemize}

These functions provide convenient ways to convert numbers between different bases in Python. By specifying the appropriate base parameter, you can convert numbers to and from binary, octal, decimal, and hexadecimal representations. In additional references of the book the systems conversion is covered with a bit more understandable example with no special functions usage.


\section{Problems and Solutions}

\begin{enumerate}
\item Write a Python program to calculate the area of a rectangle. The length and width of the rectangle are provided as inputs from the user.

\begin{lstlisting}[language=Python]
length = float(input("Enter the length of the rectangle: "))
width = float(input("Enter the width of the rectangle: "))
area = length * width
print("The area of the rectangle is:", area)
\end{lstlisting}

To calculate the area of a rectangle, we need to multiply its length by its width. The program prompts the user to enter the length and width as floating-point numbers, performs the calculation, and displays the result as the area of the rectangle.

\item Write a Python program to convert Celsius to Fahrenheit. The temperature in Celsius is provided as an input from the user.

\begin{lstlisting}[language=Python]
celsius = float(input("Enter the temperature in Celsius: "))
fahrenheit = (celsius * 9/5) + 32
print("The temperature in Fahrenheit is:", fahrenheit)
\end{lstlisting}

To convert Celsius to Fahrenheit, we can use the formula \texttt{F = (C * 9/5) + 32}, where \texttt{F} represents Fahrenheit and \texttt{C} represents Celsius. The program prompts the user to enter the temperature in Celsius, performs the conversion using the formula, and displays the result as the temperature in Fahrenheit.

 \item Write a Python program to check if a number is even or odd. The number is provided as an input from the user.

    \begin{lstlisting}[language=Python]
    number = int(input("Enter a number: "))
    if number % 2 == 0:
        print("The number is even.")
    else:
        print("The number is odd.")
    \end{lstlisting}

    To check if a number is even or odd, we use the modulus operator (\%) to find the remainder when the number is divided by 2. If the remainder is 0, the number is even; otherwise, it is odd.

    \item Write a Python program to calculate the square of a number. The number is provided as an input from the user.

    \begin{lstlisting}[language=Python]
    number = float(input("Enter a number: "))
    square = number ** 2
    print("The square of the number is:", square)
    \end{lstlisting}

    To calculate the square of a number, we use the exponentiation operator (**). We raise the number to the power of 2 to obtain its square.

    \item Write a Python program to find the maximum of three numbers. The numbers are provided as inputs from the user.

    \begin{lstlisting}[language=Python]
    num1 = float(input("Enter the first number: "))
    num2 = float(input("Enter the second number: "))
    num3 = float(input("Enter the third number: "))
    maximum = max(num1, num2, num3)
    print("The maximum number is:", maximum)
    \end{lstlisting}

    To find the maximum of three numbers, we can use the built-in \texttt{max()} function. We provide the three numbers as arguments to the \texttt{max()} function, and it returns the maximum value among them.

    \item Write a Python program to check if a year is a leap year. The year is provided as an input from the user.

    \begin{lstlisting}[language=Python]
    year = int(input("Enter a year: "))
    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
        print("The year is a leap year.")
    else:
        print("The year is not a leap year.")
    \end{lstlisting}

    To check if a year is a leap year, we use the following conditions:
    - The year must be divisible by 4.
    - If the year is divisible by 100, it must also be divisible by 400.

    If both conditions are satisfied, the year is a leap year; otherwise, it is not.

    \item Write a Python program to calculate the sum of all even numbers from 1 to 100.

    \begin{lstlisting}[language=Python]
    sum_even = 0
    for number in range(2, 101, 2):
        sum_even += number
    print("The sum of all even numbers from 1 to 100 is:", sum_even)
    \end{lstlisting}

    To calculate the sum of all even numbers from 1 to 100, we use a \texttt{for} loop to iterate over the range of numbers from 2 to 100 with a step of 2. We add each even number to the variable \texttt{sum\_even} to accumulate the sum.

    \item Write a Python program to reverse a string. The string is provided as an input from the user.

    \begin{lstlisting}[language=Python]
    string = input("Enter a string: ")
    reversed_string = string[::-1]
    print("The reversed string is:", reversed_string)
    \end{lstlisting}

    To reverse a string, we can use string slicing with a step of -1 (\texttt{[::-1]}). This will create a new string with the characters in reverse order.

    \item Write a Python program to check if a string is a palindrome. The string is provided as an input from the user.

    \begin{lstlisting}[language=Python]
    string = input("Enter a string: ")
    reversed_string = string[::-1]
    if string == reversed_string:
        print("The string is a palindrome.")
    else:
        print("The string is not a palindrome.")
    \end{lstlisting}

    To check if a string is a palindrome, we compare the original string with its reverse. If they are equal, the string is a palindrome; otherwise, it is not.

    \item Write a Python program to calculate the factorial of a number. The number is provided as an input from the user.

    \begin{lstlisting}[language=Python]
    number = int(input("Enter a number: "))
    factorial = 1
    for i in range(1, number + 1):
        factorial *= i
    print("The factorial of the number is:", factorial)
    \end{lstlisting}

    To calculate the factorial of a number, we use a \texttt{for} loop to iterate from 1 to the given number. In each iteration, we multiply the current factorial by the loop variable \texttt{i}.

\item Write a Python program to calculate the area of a triangle. The base and height of the triangle are provided as inputs from the user.
    
    \begin{lstlisting}[language=Python]
    base = float(input("Enter the base of the triangle: "))
    height = float(input("Enter the height of the triangle: "))
    area = 0.5 * base * height
    print("The area of the triangle is:", area)
    \end{lstlisting}
    
    To calculate the area of a triangle, we use the formula \texttt{A = 0.5 * base * height}, where \texttt{A} represents the area, \texttt{base} is the length of the base, and \texttt{height} is the height of the triangle.
    
    \item Write a Python program to check if a string is an anagram of another string. The two strings are provided as inputs from the user.
    
    \begin{lstlisting}[language=Python]
    string1 = input("Enter the first string: ")
    string2 = input("Enter the second string: ")
    if sorted(string1.lower()) == sorted(string2.lower()):
        print("The strings are anagrams.")
    else:
        print("The strings are not anagrams.")
    \end{lstlisting}
    
    To check if two strings are anagrams, we convert both strings to lowercase, sort the characters, and compare the sorted strings. If they are equal, the strings are anagrams; otherwise, they are not.
    
    \item Write a Python program to calculate the Fibonacci sequence up to a specified number of terms. The number of terms is provided as an input from the user.
    
    \begin{lstlisting}[language=Python]
    num_terms = int(input("Enter the number of terms: "))
    fibonacci = [0, 1]
    for i in range(2, num_terms):
        next_term = fibonacci[i-1] + fibonacci[i-2]
        fibonacci.append(next_term)
    print("The Fibonacci sequence is:", fibonacci)
    \end{lstlisting}
    
    The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones. To calculate the Fibonacci sequence, we use a \texttt{for} loop to iterate from the third term up to the specified number of terms. We calculate each term by adding the two previous terms and append it to the Fibonacci sequence list.
    
    \item Write a Python program to find the prime factors of a number. The number is provided as an input from the user.
    
    \begin{lstlisting}[language=Python]
    number = int(input("Enter a number: "))
    factors = []
    divisor = 2
    while number > 1:
        if number % divisor == 0:
            factors.append(divisor)
            number /= divisor
        else:
            divisor += 1
    print("The prime factors are:", factors)
    \end{lstlisting}
    
    Prime factors are the prime numbers that divide a given number without leaving a remainder. We start with the smallest prime factor (2) and continuously divide the number by the factor until it becomes 1. If the number is divisible by the factor, it is a prime factor, and we add it to the factors list.
    
    \item Write a Python program to sort a list of numbers in ascending order using the bubble sort algorithm. The list of numbers is provided as an input from the user.
    
    \begin{lstlisting}[language=Python]
    numbers = input("Enter a list of numbers separated by spaces: ").split()
    numbers = [int(num) for num in numbers]
    
    # Bubble sort algorithm
    for i in range(len(numbers)):
        for j in range(len(numbers) - i - 1):
            if numbers[j] > numbers[j+1]:
                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
    
    print("The sorted list is:", numbers)
    \end{lstlisting}
    
    The bubble sort algorithm repeatedly swaps adjacent elements if they are in the wrong order. We iterate through the list multiple times, comparing each pair of adjacent numbers and swapping them if necessary. This process is repeated until the list is sorted in ascending order.
    
    \item Write a Python program to calculate the sum of digits in a positive integer. The integer is provided as an input from the user.
    
    \begin{lstlisting}[language=Python]
    number = int(input("Enter a positive integer: "))
    sum_of_digits = 0
    while number > 0:
        digit = number % 10
        sum_of_digits += digit
        number //= 10
    print("The sum of digits is:", sum_of_digits)
    \end{lstlisting}
    
    To calculate the sum of digits in an integer, we continuously extract the rightmost digit (remainder of division by 10) and add it to the sum. We then divide the number by 10 to remove the rightmost digit. This process is repeated until the number becomes 0.
    
    \item Write a Python program to count the occurrences of each word in a given string. The string is provided as an input from the user.
    
    \begin{lstlisting}[language=Python]
    string = input("Enter a string: ")
    words = string.lower().split()
    word_count = {}
    for word in words:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    print("Word counts:", word_count)
    \end{lstlisting}
    
    We convert the string to lowercase and split it into individual words. We then use a dictionary (\texttt{word\_count}) to keep track of the count of each word. For each word in the list, if it already exists in the dictionary, we increment its count; otherwise, we add it to the dictionary with an initial count of 1.
    
    \item Write a Python program to generate a random password of a specified length. The length of the password is provided as an input from the user.
    
    \begin{lstlisting}[language=Python]
    import random
    import string
    
    length = int(input("Enter the length of the password: "))
    characters = string.ascii_letters + string.digits + string.punctuation
    password = ''.join(random.choice(characters) for _ in range(length))
    print("The generated password is:", password)
    \end{lstlisting}
    
    We import the \texttt{random} and \texttt{string} modules. The \texttt{characters} variable contains all possible characters for the password (letters, digits, and punctuation). We use a \texttt{for} loop and \texttt{random.choice()} function to randomly select characters from the \texttt{characters} string and join them together to form the password of the specified length.
    
    \item Write a Python program to remove duplicate elements from a list. The list is provided as an input from the user.
    
    \begin{lstlisting}[language=Python]
    numbers = input("Enter a list of numbers separated by spaces: ").split()
    numbers = [int(num) for num in numbers]
    unique_numbers = list(set(numbers))
    print("List with duplicates removed:", unique_numbers)
    \end{lstlisting}
    
    We first split the user input into a list of numbers and convert them to integers. Then, we convert the list to a set, which automatically removes duplicate elements due to the nature of sets. Finally, we convert the set back to a list to preserve the original order of the elements.
    
    \item Write a Python program to find the intersection of two lists. The two lists are provided as inputs from the user.
    
    \begin{lstlisting}[language=Python]
    list1 = input("Enter the first list of numbers separated by spaces: ").split()
    list2 = input("Enter the second list of numbers separated by spaces: ").split()
    list1 = [int(num) for num in list1]
    list2 = [int(num) for num in list2]
    intersection = list(set(list1) & set(list2))
    print("The intersection of the two lists is:", intersection)
    \end{lstlisting}
    
    We split the user inputs into two lists of numbers and convert them to integers. We then use the \texttt{set()} function to convert each list to a set. The ampersand operator (\&) is used to find the intersection of the two sets, which contains the common elements. Finally, we convert the intersection set back to a list.
    
    \item Write a Python program to perform a bitwise AND operation on two integers. The integers are provided as inputs from the user.

\begin{lstlisting}[language=Python]
num1 = int(input("Enter the first integer: "))
num2 = int(input("Enter the second integer: "))
result = num1 & num2
print("The result of the bitwise AND operation is:", result)
\end{lstlisting}

The bitwise AND operator (&) performs a bitwise logical AND operation between the corresponding bits of two integers. The program prompts the user to enter two integers, performs the bitwise AND operation, and displays the result.

\item Write a Python program to perform a bitwise OR operation on two integers. The integers are provided as inputs from the user.

\begin{lstlisting}[language=Python]
num1 = int(input("Enter the first integer: "))
num2 = int(input("Enter the second integer: "))
result = num1 | num2
print("The result of the bitwise OR operation is:", result)
\end{lstlisting}

The bitwise OR operator (\texttt{|}) performs a bitwise logical OR operation between the corresponding bits of two integers. The program prompts the user to enter two integers, performs the bitwise OR operation, and displays the result.

\item Write a Python program to perform a bitwise XOR operation on two integers. The integers are provided as inputs from the user.

\begin{lstlisting}[language=Python]
num1 = int(input("Enter the first integer: "))
num2 = int(input("Enter the second integer: "))
result = num1 ^ num2
print("The result of the bitwise XOR operation is:", result)
\end{lstlisting}

The bitwise XOR operator (\texttt{\^}) performs a bitwise logical XOR (exclusive OR) operation between the corresponding bits of two integers. The program prompts the user to enter two integers, performs the bitwise XOR operation, and displays the result.

\item Write a Python program to perform a bitwise NOT operation on an integer. The integer is provided as an input from the user.

\begin{lstlisting}[language=Python]
num = int(input("Enter an integer: "))
result = ~num
print("The result of the bitwise NOT operation is:", result)
\end{lstlisting}

The bitwise NOT operator (\texttt{~{}}) performs a bitwise logical NOT operation on each bit of an integer, inverting its value. The program prompts the user to enter an integer, performs the bitwise NOT operation, and displays the result.

\item Write a Python program to perform a left shift operation on an integer. The integer and the number of positions to shift are provided as inputs from the user.

\begin{lstlisting}[language=Python]
num = int(input("Enter an integer: "))
shift = int(input("Enter the number of positions to shift: "))
result = num << shift
print("The result of the left shift operation is:", result)
\end{lstlisting}

The left shift operator (\texttt{<<}) shifts the bits of an integer to the left by the specified number of positions. The program prompts the user to enter an integer and the number of positions to shift, performs the left shift operation, and displays the result.

\item Write a Python program to perform a right shift operation on an integer. The integer and the number of positions to shift are provided as inputs from the user.

\begin{lstlisting}[language=Python]
num = int(input("Enter an integer: "))
shift = int(input("Enter the number of positions to shift: "))
result = num >> shift
print("The result of the right shift operation is:", result)
\end{lstlisting}

The right shift operator (\texttt{>>}) shifts the bits of an integer to the right by the specified number of positions. The program prompts the user to enter an integer and the number of positions to shift, performs the right shift operation, and displays the result.

\item Write a Python program to check if a specific bit is set in an integer. The integer and the position of the bit are provided as inputs from the user.

\begin{lstlisting}[language=Python]
num = int(input("Enter an integer: "))
position = int(input("Enter the position of the bit: "))
mask = 1 << position
result = (num & mask) != 0
print("The bit is set:", result)
\end{lstlisting}

The program prompts the user to enter an integer and the position of the bit to check. It creates a mask with the bit set at the specified position. The bitwise AND operation is performed between the integer and the mask to extract the value of the bit at that position. The result is then checked if it is not equal to 0, indicating that the bit is set.

\item Write a Python program to set a specific bit in an integer. The integer, the position of the bit, and the value (0 or 1) are provided as inputs from the user.

\begin{lstlisting}[language=Python]
num = int(input("Enter an integer: "))
position = int(input("Enter the position of the bit: "))
value = int(input("Enter the value (0 or 1): "))
mask = 1 << position
if value == 1:
result = num | mask
else:
result = num & (~mask)
print("The result after setting the bit is:", result)
\end{lstlisting}

The program prompts the user to enter an integer, the position of the bit to set, and the value (0 or 1) to set. It creates a mask with the bit set at the specified position. If the value is 1, the bitwise OR operation is performed between the integer and the mask to set the bit. If the value is 0, the bitwise AND operation is performed between the integer and the complement of the mask to clear the bit. The result is then displayed.

\item Write a Python program to check if any bit is set in an integer. The integer is provided as an input from the user.

\begin{lstlisting}[language=Python]
num = int(input("Enter an integer: "))
result = num != 0
print("Any bit is set:", result)
\end{lstlisting}

The program prompts the user to enter an integer. It checks if the integer is not equal to 0, indicating that at least one bit is set. The result is then displayed.

\item Write a Python program to perform logical AND, OR, and NOT operations on two Boolean values. The Boolean values are provided as inputs from the user.

\begin{lstlisting}[language=Python]
value1 = bool(input("Enter the first Boolean value: "))
value2 = bool(input("Enter the second Boolean value: "))
logical_and = value1 and value2
logical_or = value1 or value2
logical_not1 = not value1
logical_not2 = not value2
print("Logical AND:", logical_and)
print("Logical OR:", logical_or)
print("Logical NOT (value1):", logical_not1)
print("Logical NOT (value2):", logical_not2)
\end{lstlisting}

The program prompts the user to enter two Boolean values. It performs the logical AND (\texttt{and}), logical OR (\texttt{or}), and logical NOT (\texttt{not}) operations on the values and displays the results.

\end{enumerate}

\newpage
\newpage
\chapter{Control Flow}
Control flow refers to the order in which the program's code executes. The control flow of a Python program is regulated by conditional statements, loops, and function calls.

\section{If Statements}

The `if` statement is used for conditional execution in Python. It executes a block of code if a specified condition is true:
\begin{Example}
\begin{lstlisting}[language=Python]
if 5 > 2:
    print("Five is greater than two!")
\end{lstlisting}
\end{Example}
In this example, the condition is `5 > 2` which is true, so the print statement is executed.


\subsubsection{The else keyword}
The `else` keyword in Python is used to define a block of code to be executed if the condition in the `if` statement is false:

Below the function which will tell if the 5 is less than 2 or else if the 5 is greater or equal than 5
\begin{Example}
\begin{lstlisting}[language=Python]
if 5 < 2:
    print("Five is less than two!")
else:
    print("Five is not less than two!")
\end{lstlisting}
\end{Example}
In this example, because the condition `5 < 2` is false, the print statement under the `else` keyword is executed.


\subsubsection{The elif keyword}
The `elif` keyword in Python is short for "else if". It allows you to specify a new condition to be checked if the first condition is false:
\begin{Example}
Lets make the consideration if the x is less than defined numbers:
\begin{lstlisting}[language=Python]
x = 20
if x < 10:
    print("x is less than 10")
elif x < 30:
    print("x is less than 30")
else:
    print("x is 30 or more")
\end{lstlisting}
\end{Example}
In this example, because `x` is `20`, the condition `x < 10` is false, so Python moves on to the `elif` statement. The condition `x < 30` is true, so the corresponding print statement is executed.


\section{While Loops}

A `while` loop in Python executes a block of code as long as a specified condition is true:
\begin{Example}
\begin{lstlisting}[language=Python]
i = 1
while i < 6:
    print(i)
    i += 1
\end{lstlisting}
\end{Example}
In this example, as long as `i` is less than `6`, the loop will continue to execute and print the value of `i`. The `i += 1` statement increments `i` by `1` after each loop iteration.

Here are a few more complex examples and constructions using while loops:

\begin{Example}
\begin{lstlisting}[language=Python]
% Sum of numbers from 1 to 10
total = 0
i = 1
while i <= 10:
    total += i
    i += 1
print("Sum:", total)

% Countdown from 10 to 1
num = 10
while num >= 1:
    print(num)
    num -= 1
print("Blastoff!")

% Finding the first Fibonacci number greater than 1000
a, b = 0, 1
while b <= 1000:
    a, b = b, a + b
print("First Fibonacci number greater than 1000:", b)
\end{lstlisting}
\end{Example}

In Example 1, the loop calculates the sum of numbers from 1 to 10 using the \texttt{total} variable. Example 2 demonstrates a countdown from 10 to 1, and the loop prints the current value of \texttt{num} in each iteration. Finally, Example 3 finds the first Fibonacci number greater than 1000 using the variables \texttt{a} and \texttt{b} to keep track of the current and previous Fibonacci numbers.

Feel free to customize and experiment with these examples to further explore the capabilities of while loops in Python.

\section{For Loops}

A `for` loop in Python is used to iterate over a sequence (like a list, tuple, set, or string) or other iterable objects. Iterating over a sequence is called traversal. 

\subsubsection{Iterating over lists}
Here's an example of a `for` loop in Python that iterates over a list:
\begin{Example}
\begin{lstlisting}[language=Python]
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)
\end{lstlisting}
\end{Example}
In this example, `fruit` is a variable that takes the value of the next item in `fruits` each time through the loop. So, this `for` loop will print each fruit in the `fruits` list.

\subsubsection{Using the range() function}

The range() function in Python is used to generate a sequence of numbers which might be used to iterating through using for loop. Here are some examples:

\begin{enumerate}
    \item With only one argument: \\
    \begin{Example}
    \begin{lstlisting}[language=Python]
    for i in range(5):
        print(i)
    \end{lstlisting}
    \end{Example}
    This will output the numbers 0 through 4. Note that `range(5)` generates numbers from 0 to 4, not up to 5. This is because `range()` generates numbers up to, but not including, the end value you specify.

    \item With two arguments: \\
    \begin{Example}
    \begin{lstlisting}[language=Python]
    for i in range(2, 5):
        print(i)
    \end{lstlisting}
    \end{Example}
    This will output the numbers 2 through 4. Here, `range(2, 5)` generates numbers from 2 up to, but not including, 5.

    \item With three arguments: \\
    \begin{Example}
    \begin{lstlisting}[language=Python]
    for i in range(0, 10, 2):
        print(i)
    \end{lstlisting}
    \end{Example}
    This will output the numbers 0, 2, 4, 6, and 8. Here, `range(0, 10, 2)` generates numbers from 0 up to, but not including, 10, with a step of 2.
\end{enumerate}

\subsubsection{Nested for loops}
You can use a `for` loop inside another `for` loop to iterate over multiple dimensions of data. This is known as a nested loop. For example:
\begin{Example}
\begin{lstlisting}[language=Python]
for i in range(3):
    for j in range(3):
        print(i, j)
\end{lstlisting}
\end{Example}
In this example, the outer loop runs three times, and each time it runs, the inner loop also runs three times. This results in a total of nine iterations of the inner loop, once for each combination of `i` and `j` values.

\subsubsection{The enumerate() function}
When iterating over a sequence, you may sometimes want to know the index of the current item in the sequence. You can use the `enumerate()` function for this:
\begin{Example}
\begin{lstlisting}[language=Python]
for i, fruit in enumerate(fruits):
    print(f"The fruit at index {i} is {fruit}.\n")
\end{lstlisting}
\end{Example}
In this example, `enumerate(fruits)` generates a sequence of pairs, where the first element of each pair is the index and the second element is the corresponding item from `fruits`. The `for` loop then unpacks each pair into `i` and `fruit`. At the end of the f-stting constructed there is a new line symbol  \texttt{\textbackslash n}.


\section{Break, Continue, and Pass}

Control flow isn't just about determining the sequence of execution; it's also about having control over that sequence when necessary. Python provides three essential keywords that can influence loops in various ways: `break`, `continue`, and `pass`.

\subsubsection{Break}
The \textbf{break} statement is used to exit the loop prematurely. Once a \textbf{break} statement is encountered, Python will terminate the loop and move on to the next line of code after the loop. This is particularly useful when you're searching for something or when you need to stop a loop based on a specific condition.

\begin{Example}
\begin{lstlisting}[language=Python]
for num in range(10):
    if num == 5:
        break
    print(num)
\end{lstlisting}
\end{Example}
Here, numbers from 0 to 4 are printed. When the loop encounters the number `5`, the \textbf{break} statement is executed, and the loop terminates.

\subsubsection{Continue}
While \textbf{break} stops the loop, the \textbf{continue} statement stops the current iteration and continues with the next one. It can be used when you want to skip a specific iteration based on a condition.

\begin{Example}
\begin{lstlisting}[language=Python]
for num in range(10):
    if num % 2 == 0:  # checks if the number is even
        continue
    print(num)
\end{lstlisting}
\end{Example}
In this example, only odd numbers between 0 and 9 are printed. If an even number is detected, the `continue` statement is executed, and the loop skips the `print` statement for that iteration.

\subsubsection{Pass}
The \textbf{pass} statement is a no-operation placeholder. It's a command that does nothing and can be used when a statement is syntactically required but you don't want to execute any command or code. It's often used as a placeholder with the intention of filling it in later.

\begin{Example}
\begin{lstlisting}[language=Python]
for num in range(10):
    if num % 2 == 0:
        pass  # we'll handle this later
    else:
        print(f"{num} is odd")
\end{lstlisting}
\end{Example}
Here, every even number will encounter the \textbf{pass} statement, essentially doing nothing for that iteration. The odd numbers will have their value printed.

\section{Conclusion}
Mastering control flow in Python is crucial for creating efficient and effective algorithms. In the previous chapter some examples of the practical usage have already been mentioned. In the next we will also has a grate to chance to participate in the control flow father discussion. With a combination of conditional statements, loops, and control keywords, you can create complex logic for your programs. The examples and advanced constructions provided here should offer a deeper understanding, but the best way to become proficient is to practice, experiment, and apply these concepts in real-world scenarios.

\newpage
\section{Problems and solutions}

\begin{enumerate}
    \item \textbf{Basic If Statement}: Check if a given number is even or odd. \\

    \begin{lstlisting}[language=Python]
num = int(input("Enter a number: "))
if num % 2 == 0:
    print("Even")
else:
    print("Odd")
    \end{lstlisting}

    \item \textbf{Elif Construction}: Determine if a number is negative, positive, or zero. \\

    \begin{lstlisting}[language=Python]
num = int(input("Enter a number: "))
if num > 0:
    print("Positive")
elif num < 0:
    print("Negative")
else:
    print("Zero")
    \end{lstlisting}

    \item \textbf{Simple While Loop}: Print numbers from 1 to 5 using a `while` loop. \\

    \begin{lstlisting}[language=Python]
i = 1
while i <= 5:
    print(i)
    i += 1
    \end{lstlisting}

    \item \textbf{For Loop with Strings}: Print each character of a given string. \\

    \begin{lstlisting}[language=Python]
for char in "hello":
    print(char)
    \end{lstlisting}

    \item \textbf{Range Function}: Print all odd numbers between 1 and 10. \\
    \textit{Solution:}
    \begin{lstlisting}[language=Python]
for num in range(1, 11, 2):
    print(num)
    \end{lstlisting}

    \item \textbf{Break in For Loop}: Search for the first vowel in a given string. \\

    \begin{lstlisting}[language=Python]
string = "pythonista"
for char in string:
    if char in 'aeiou':
        print(char)
        break
    \end{lstlisting}

    \item \textbf{Continue in For Loop}: Print all numbers in a range except those divisible by 3. \\

    \begin{lstlisting}[language=Python]
for num in range(10):
    if num % 3 == 0:
        continue
    print(num)
    \end{lstlisting}

    \item \textbf{Nested Loops}: Using two loops, print pairs of numbers (i, j) where i and j both range from 1 to 3. \\

    \begin{lstlisting}[language=Python]
for i in range(1, 4):
    for j in range(1, 4):
        print(i, j)
    \end{lstlisting}

    \item \textbf{Enumerate Function}: Given a list of colors, print each color with its index. \\

    \begin{lstlisting}[language=Python]
colors = ["red", "green", "blue"]
for index, color in enumerate(colors):
    print(index, color)
    \end{lstlisting}

    \item \textbf{While Loop with Break}: Create a loop that continuously asks the user for input and breaks when the user enters "stop". \\

    \begin{lstlisting}[language=Python]
while True:
    text = input("Enter text (or 'stop' to exit): ")
    if text == "stop":
        break
    \end{lstlisting}

    \item \textbf{For Loop with Else}: Use a for loop to search for a number in a list. If the number is not found, print a message using the else clause of the for loop. \\

\begin{lstlisting}[language=Python]
numbers = [1, 3, 5, 7, 9]
for num in numbers:
    if num == 4:
        break
else:
    print("Number 4 is not in the list.")
\end{lstlisting}

	\item \textbf{Nested Conditional Statements}: Check if a given number is positive even, positive odd, negative even, negative odd, or zero. \\

\begin{lstlisting}[language=Python]
num = int(input("Enter a number: "))
if num > 0:
    if num % 2 == 0:
        print("Positive even")
    else:
        print("Positive odd")
elif num < 0:
    if num % 2 == 0:
        print("Negative even")
    else:
        print("Negative odd")
else:
    print("Zero")
\end{lstlisting}

	\item \textbf{Using pass in a Loop}: Iterate over a range of numbers. If the number is even, do nothing using the `pass` statement, otherwise, print the number. \\

\begin{lstlisting}[language=Python]
for i in range(1, 6):
    if i % 2 == 0:
        pass
    else:
        print(i)
\end{lstlisting}

	\item \textbf{Infinite Loop with Break}: Create a loop that will run indefinitely until a certain user input is given, then use `break` to exit the loop. \\

\begin{lstlisting}[language=Python]
while True:
    response = input("Enter 'q' to quit: ")
    if response == 'q':
        break
\end{lstlisting}

	\item \textbf{Skip Even Numbers Using Continue}: Iterate over numbers from 1 to 10, but skip printing even numbers using the `continue` statement. \\

\begin{lstlisting}[language=Python]
for num in range(1, 11):
    if num % 2 == 0:
        continue
    print(num)
\end{lstlisting}

	\item \textbf{Nested Loops to Generate Patterns}: Use nested loops to generate a pattern of stars, where each line contains 1 more star than the previous line, for 5 lines. \\

\begin{lstlisting}[language=Python]
for i in range(1, 6):
    for j in range(i):
        print("*", end="")
    print()
\end{lstlisting}

\end{enumerate}

\newpage
\newpage
\chapter{Functions}

Functions in Python are defined using the `def` keyword. Functions allow for code reuse and can make programs more modular and easier to understand. Here's how you can define a function in Python:
\begin{Example}
\begin{lstlisting}[language=Python]
def my_function():
    print("Hello from a function")
\end{lstlisting}
\end{Example}
In this example, `my\_function` is a function that prints "Hello from a function" when called.


\section{Calling a Function}
To call a function in Python, you simply need to write the function's name followed by parentheses. Here's how you can call the function we defined earlier:
\begin{lstlisting}[language=Python]
my_function()
\end{lstlisting}

\section{Parameters and Arguments}
Functions can also take parameters, which are values that you can pass into the function. The parameters are defined in the function definition, and the values you pass in are called arguments. Here's an example of a function with parameters:

Lets imagine we have to write the function to greet the user after they input their name:
\begin{Example} 
\begin{lstlisting}[language=Python]
def greet(name):
    print(f"Hello, {name}!")
    
greet("Alice")
\end{lstlisting}
\end{Example}

In this example, `name` is a parameter. You can call this function with an argument like this:
This will output: "Hello, Alice!".

\section{Return Values}
Functions in Python can also return values. This is done using the `return` statement. Here's an example of a function that returns a value:

\begin{Example}
\begin{lstlisting}[language=Python]
def square(number):
    return number ** 2
\end{lstlisting}
In this example, the `square` function takes a number as a parameter and returns the square of that number. You can call this function and store its return value in a variable like this:
\begin{lstlisting}[language=Python]
squared = square(5)
print(squared)  # Output: 25
\end{lstlisting}
\end{Example}

\section{Default Parameter Value}
In Python, you can also provide a default value for a function's parameters. This value will be used if the function is called without an argument for that parameter. Here's an example:


Lets create a function that takes the parameter of the name of the user but also has its default value set as the Stranger string:
\begin{Example}
\begin{lstlisting}[language=Python]
def greet(name="Stranger"):
    print(f"Hello, {name}!")
\end{lstlisting}
In this example, if the `greet` function is called without an argument, it will use "Stranger" as the default value for the `name` parameter:
\begin{lstlisting}[language=Python]
greet()  # Output: Hello, Stranger!
\end{lstlisting}
\end{Example}

\section{Multiple Parameters and Arguments}
Python functions can take multiple parameters. You just need to separate them with a comma in the function definition. Here's an example:


A function to compute the sum of two numbers:
\begin{Example}
\begin{lstlisting}[language=Python]
def add_numbers(num1, num2):
	return num1 + num2
\end{lstlisting}
You can call this function with two arguments like this:
\begin{lstlisting}[language=Python]
sum = add_numbers(5, 7)
print(sum) # Output: 12
\end{lstlisting}
\end{Example}

\section{Variable-length Arguments}
Sometimes you may want to define a function that can take any number of arguments. You can do this in Python using *args and **kwargs. Here's an example:


A function that accepts any number of arguments and returns their sum:
\begin{Example}
\begin{lstlisting}[language=Python]
def add_numbers(*args):
	return sum(args)
\end{lstlisting}
You can call this function with any number of arguments like this:
\begin{lstlisting}[language=Python]
sum = add_numbers(1, 2, 3, 4, 5)
print(sum) # Output: 15
\end{lstlisting}
\end{Example}

\section{Function Annotations}

Function annotations provide a way of associating various parts of a function with arbitrary python expressions at compile time. The annotations can be useful for type-checking and documentation:

\begin{lstlisting}[language=Python]
def multiply(a: int, b: int) -> int:
    return a * b
\end{lstlisting}

\section{Docstrings}

Documentation strings, or docstrings, provide a way to associate documentation with Python program entities:

\begin{lstlisting}[language=Python]
def add(a, b):
    """This function adds two numbers and returns the result."""
    return a + b
\end{lstlisting}

You can access the docstring using the \texttt{\_\_doc\_\_} attribute of the function.

\section{First-Class Functions}

In Python, functions are first-class citizens, meaning they can be used as values:

\begin{lstlisting}[language=Python]
def greet():
    return "Hello"

# Assign function to a variable
say_hello = greet
print(say_hello())
\end{lstlisting}

\section{Closures}

Closures allow a nested function to capture and remember values from its containing scope:

\begin{lstlisting}[language=Python]
def outer_function(x):
    def inner_function(y):
        return x + y
    return inner_function

closure = outer_function(10)
print(closure(5))
\end{lstlisting}


\section{Decorators}

Decorators are a powerful and expressive tool in Python, allowing programmers to modify the behavior of functions or methods without changing their actual code. They are a form of metaprogramming and are often used for logging, enforcing access control, instrumentation, and more.

In essence, a decorator is a higher-order function, meaning it takes one or more functions as arguments and returns a new function. The new function usually extends or alters the behavior of the original function in some way.

The `@` syntax before a function definition is a syntactic sugar and is just an easier way of writing `say_hello = my_decorator(say_hello)`. 

Here's an example of a simple decorator:

\begin{lstlisting}[language=Python]
def my_decorator(func):
    def wrapper():
        print("Something before the function.")
        func()
        print("Something after the function.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")
    
say_hello()
\end{lstlisting}

When you call the function \texttt{say\_hello()}, as we did in the last line of the previous example, you'll get the following output:

\begin{lstlisting}
Something before the function.
Hello!
Something after the function.
\end{lstlisting}

Decorators can also take arguments, allowing for more customizable behavior. They can be stacked to apply multiple decorators to a single function, and can also be used to decorate class methods.


\section{Recursive Functions}
A recursive function is a function that calls itself during its execution. This enables the function to be repeated several times, as it can call itself during its execution. Here's an example of a recursive function:


A function to compute the factorial of a number using recursion:
\begin{Example}
\begin{lstlisting}[language=Python]
def factorial(n):
	if n == 1:
		return 1
	else:
		return n * factorial(n-1)
\end{lstlisting}
You can call this function like this:
\begin{lstlisting}[language=Python]
fact = factorial(5)
print(fact) # Output: 120
\end{lstlisting}
\end{Example}

\section{Lambda Functions}
In Python, anonymous function means that a function is without a name. The lambda keyword is used to create anonymous functions. Here's an example:


A lambda function to compute the square of a number:
\begin{Example}
\begin{lstlisting}[language=Python]
square = lambda x : x ** 2
\end{lstlisting}
You can call this function like this:
\begin{lstlisting}[language=Python]
sq = square(5)
print(sq) # Output: 25
\end{lstlisting}
\end{Example}
\newpage

\section{Problems on Functions}

\begin{enumerate}
  \item \textbf{Basic Function}
Write a function named `welcome` that prints "Welcome to Python!".


\begin{lstlisting}[language=Python]
def welcome():
    print("Welcome to Python!")
\end{lstlisting}

\item \textbf{ Function with Parameter}
Create a function `display` that takes a string as a parameter and prints it.


\begin{lstlisting}[language=Python]
def display(message):
    print(message)
\end{lstlisting}

\item \textbf{Function Returning Value}
Define a function `add` that takes two numbers as parameters and returns their sum.


\begin{lstlisting}[language=Python]
def add(a, b):
    return a + b
\end{lstlisting}

\item \textbf{Default Parameter}
Write a function \textbf{display\_name} that takes a name as a parameter and prints it. If no name is provided, it should print "Guest".


\begin{lstlisting}[language=Python]
def display_name(name="Guest"):
    print(name)
\end{lstlisting}

\item \textbf{Multiple Parameters}
Design a function \textbf{multiply} that takes two numbers and returns their product.

\begin{lstlisting}[language=Python]
def multiply(a, b):
    return a * b
\end{lstlisting}

\item \textbf{Variable-length Arguments}
Create a function \textbf{find\_max} that finds and returns the maximum number from any given numbers.


\begin{lstlisting}[language=Python]
def find_max(*args):
    return max(args)
\end{lstlisting}

\item \textbf{Function Annotations}
Design a function with annotations that takes two floats as parameters and returns their division.


\begin{lstlisting}[language=Python]
def divide(a: float, b: float) -> float:
    return a / b
\end{lstlisting}

\item \textbf{Using Docstrings}
Write a function to compute the area of a circle given its radius. Include a docstring to explain its purpose.


\begin{lstlisting}[language=Python]
def area_circle(radius):
    """Compute the area of a circle given its radius."""
    return 3.14159 * radius * radius
\end{lstlisting}

\item \textbf{First-Class Functions}
Assign the \textbf{add} function you wrote in Problem 3 to a variable \textbf{sum\_func} and demonstrate its usage.


\begin{lstlisting}[language=Python]
sum_func = add
result = sum_func(3, 4)  # result will be 7
\end{lstlisting}

\item \textbf{Closure}
Write a closure that returns a function to compute the power of a given number.


\begin{lstlisting}[language=Python]
def power(n):
    def compute(x):
        return x ** n
    return compute
\end{lstlisting}

\item \textbf{Simple Decorator}
Create a decorator \textbf{bold\_print} that prints the decorated function's output surrounded by asterisks.


\begin{lstlisting}[language=Python]
def bold_print(func):
    def wrapper(*args, **kwargs):
        print("*****")
        func(*args, **kwargs)
        print("*****")
    return wrapper

@bold_print
def message():
    print("Hello World!")
\end{lstlisting}

\item \textbf{Recursive Function}
Write a recursive function to compute the Fibonacci series up to the nth term.


\begin{lstlisting}[language=Python]
def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)
\end{lstlisting}

\item \textbf{Lambda Function}
Use a lambda function to compute the cube of a number.


\begin{lstlisting}[language=Python]
cube = lambda x: x ** 3
\end{lstlisting}

\item \textbf{Function Returning Function}
Write a function `operation` that takes a character (either '+' or '-') and returns the appropriate function (either add or subtract).


\begin{lstlisting}[language=Python]
def add(x, y):
    return x + y

def subtract(x, y):
    return x - y

def operation(op):
    if op == '+':
        return add
    else:
        return subtract
\end{lstlisting}

\item \textbf{Function with Both *args and **kwargs}
Design a function \textbf{display\_data} that can accept any number of positional and keyword arguments and prints them.


\begin{lstlisting}[language=Python]
def display_data(*args, **kwargs):
    for arg in args:
        print(arg)
    for key, value in kwargs.items():
        print(f"{key}: {value}")
\end{lstlisting}

\item \textbf{Nested Functions}
Write a function that contains three nested functions. Each nested function should print a message.

\textbf{Solution:}
\begin{lstlisting}[language=Python]
def outer():
    print("This is the outer function.")

    def first():
        print("This is the first nested function.")

    def second():
        print("This is the second nested function.")

    def third():
        print("This is the third nested function.")

    first()
    second()
    third()
\end{lstlisting}

\item \textbf{Recursive Power Function}
Write a recursive function to compute the power of a number raised to an integer.


\begin{lstlisting}[language=Python]
def power(base, exp):
    if exp == 0:
        return 1
    else:
        return base * power(base, exp-1)
\end{lstlisting}

\item \textbf{Decorator with Arguments}
Write a decorator `repeat(n)` that repeats the execution of the decorated function n times.


\begin{lstlisting}[language=Python]
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def message():
    print("Repeated Message!")
\end{lstlisting}

\item \textbf{Lambda with Multiple Inputs}
Use a lambda function to add three numbers.


\begin{lstlisting}[language=Python]
add_three = lambda x, y, z: x + y + z
\end{lstlisting}

\item \textbf{Function that Returns Lambda}
Write a function that returns a lambda function to compute the nth power of a number.


\begin{lstlisting}[language=Python]
def nth_power(n):
    return lambda x: x ** n
\end{lstlisting}
\end{enumerate}


\newpage
\newpage
\chapter{Object-Oriented Programming}
Object-Oriented Programming (OOP) is a programming paradigm that focuses on the concept of objects, which are instances of classes. It allows for the organization of code into reusable and modular components. Python is an object-oriented programming language that fully supports OOP concepts. In this section, we will explore the key principles and features of OOP in Python.

\section{Classes and Objects}

At the core of OOP is the concept of classes and objects. A class is a blueprint for creating objects, which are instances of that class. It defines the attributes (data) and methods (functions) that the objects will have. Here's an example of a simple class in Python:

\begin{Example}
\begin{lstlisting}[language=Python]
class Circle:
    def __init__(self, radius):
        self.radius = radius

    def calculate_area(self):
        return 3.14 * self.radius**2

# Create an instance of the Circle class
my_circle = Circle(5)

# Accessing attributes and calling methods
print(my_circle.radius)  # Output: 5
print(my_circle.calculate_area())  # Output: 78.5
\end{lstlisting}
\end{Example}

In the above example, we define a \texttt{Circle} class with an attribute \texttt{radius} and a method \texttt{calculate\_area()}. We then create an instance of the \texttt{Circle} class called \texttt{my\_circle} and access its attributes and methods using the dot notation.

\section{Inheritance}

Inheritance is a powerful feature in OOP that allows a class to inherit attributes and methods from another class. The class that is being inherited from is called the base class or superclass, and the class that inherits from it is called the derived class or subclass. The derived class can add its own attributes and methods or override the ones inherited from the base class.

\begin{Example}
\begin{lstlisting}[language=Python]
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("Subclass must implement this method")


class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

my_dog = Dog("Buddy")
my_cat = Cat("Whiskers")

print(my_dog.speak())  # Output: Woof!
print(my_cat.speak())  # Output: Meow!
\end{lstlisting}
\end{Example}

In the above example, we define an \texttt{Animal} base class with an abstract method \texttt{speak()}. We then create two derived classes, \texttt{Dog} and \texttt{Cat}, that inherit from the \texttt{Animal} class and provide their own implementation of the \texttt{speak()} method.

\section{Encapsulation and Data Hiding}

Encapsulation is the practice of bundling data and methods together within a class, hiding the internal details of how the data is stored and processed. In Python, we can achieve encapsulation by using private and protected attributes and methods.

Private attributes and methods are indicated by prefixing them with two underscores (\_\_). They can only be accessed within the class itself and not from outside the class or its subclasses. Protected attributes and methods are indicated by prefixing them with a single underscore (\_). They can be accessed within the class, its subclasses, and even from outside the class, but it is considered best practice not to do so. Here's an example:

\begin{Example}
\begin{lstlisting}[language=Python]
class Car:
    def __init__(self, brand, model, year):
        self.__brand = brand
        self._model = model
        self.year = year

    def start_engine(self):
        print("Engine started.")

    def __private_method(self):
        print("This is a private method.")

my_car = Car("Toyota", "Camry", 2022)
print(my_car.__brand)  # Raises an AttributeError
print(my_car._model)  # Accessible, but conventionally considered protected
print(my_car.year)  # Accessible
my_car.start_engine()  # Outputs: Engine started.
my_car.__private_method()  # Raises an AttributeError
\end{lstlisting}
\end{Example}

In the above example, the \texttt{Car} class has a private attribute \texttt{\_\_brand}, a protected attribute \texttt{\_model}, and a public attribute \texttt{year}. It also has a public method \texttt{start\_engine()} and a private method \texttt{\_\_private\_method()}.

When accessing the attributes and methods, we see that \texttt{\_\_brand} raises an \texttt{AttributeError} because it is private and cannot be accessed from outside the class. \texttt{\_model} is accessible, but it is conventionally considered protected and should be accessed with caution. \texttt{year} can be accessed freely as it is a public attribute. Similarly, the public method \texttt{start\_engine()} can be called, but the private method \texttt{\_\_private\_method()} raises an \texttt{AttributeError}.

Encapsulation helps in creating robust and maintainable code by controlling the access to class attributes and methods, preventing unintended modifications, and encapsulating the internal implementation details.

\section{Polymorphism}
Polymorphism allows objects of different classes to be treated as objects of a common super class. It's an important principle that fosters flexibility and extensibility.

\begin{lstlisting}[language=Python]
def animal_speak(animal):
    return animal.speak()

a = Dog("Buddy")
b = Cat("Mittens")

print(animal_speak(a))  # Outputs: Woof!
print(animal_speak(b))  # Outputs: Meow!
\end{lstlisting}

\section{Composition}
Composition is a design principle where a class is composed of one or more objects from other classes, rather than inheriting from them.

\begin{lstlisting}[language=Python]
class Engine:
    def start(self):
        return "Engine starting!"

class Car:
    def __init__(self):
        self.engine = Engine()

    def start(self):
        return self.engine.start()

car = Car()
print(car.start())  # Outputs: Engine starting!
\end{lstlisting}



These are just some of the key features of object-oriented programming in Python. There are many more concepts and techniques that can be explored to leverage the power of OOP in your Python programs.

\section{General Case of Usage and Simple Example}

In addition to the concepts discussed above, we can implement classes for geometric figures such as triangles, rectangles, and circles, with methods to calculate their areas and perimeters. Here's an example:

\begin{Example}
\begin{lstlisting}[language=Python]
import math

class GeometricFigure:
    def area(self):
        raise NotImplementedError("Subclass must implement this method")

    def perimeter(self):
        raise NotImplementedError("Subclass must implement this method")

class Triangle(GeometricFigure):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):
        return 0.5 * self.base * self.height

    def perimeter(self):
        return 3 * self.base

class Rectangle(GeometricFigure):
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

    def perimeter(self):
        return 2 * (self.length + self.width)

class Circle(GeometricFigure):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius**2

    def perimeter(self):
        return 2 * math.pi * self.radius

# Create instances of geometric figures
triangle = Triangle(5, 3)
rectangle = Rectangle(4, 6)
circle = Circle(2)

# Calculate and display areas and perimeters
print("Triangle: Area =", triangle.area(), "Perimeter =", triangle.perimeter())
print("Rectangle: Area =", rectangle.area(), "Perimeter =", rectangle.perimeter())
print("Circle: Area =", circle.area(), "Circumference =", circle.perimeter())
\end{lstlisting}

\end{Example}
In the above example, we explored the concepts of inheritance, polymorphism, and encapsulation in object-oriented programming.

Inheritance allows a class to inherit attributes and methods from a base class. In this case, the Triangle, Rectangle, and Circle classes inherit from the GeometricFigure class. By doing so, they gain access to the area() and perimeter() methods defined in the base class. This promotes code reuse and allows for a hierarchical organization of related classes.

Polymorphism allows objects of different classes to be treated as objects of a common base class. In our example, we can treat instances of Triangle, Rectangle, and Circle as objects of the GeometricFigure class. This means we can use them interchangeably when calling the area() and perimeter() methods. The appropriate implementation for each class will be automatically invoked at runtime, based on the actual type of the object.

Encapsulation is the practice of bundling data and methods together within a class, hiding the internal details of how the data is stored and processed. In our example, the internal workings of each geometric figure class are encapsulated within their respective classes. The data (such as base, height, length, width, and radius) is stored as instance variables and can only be accessed or modified through the defined methods (area() and perimeter()). This helps in creating modular and maintainable code, as the internal implementation can be changed without affecting the code that uses the objects.

By employing inheritance, polymorphism, and encapsulation, we can design flexible and modular object-oriented programs that are easier to understand, maintain, and extend.

\newpage
\section{Problems on OOP}

\begin{enumerate}
    \item \textbf{Singleton Pattern}: Ensure that a class has only one instance, and provide a global point of access to it.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Singleton:
    _instance = None
    
    def __new__(cls):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance
    \end{lstlisting}

    \item \textbf{Factory Pattern}: Create a class that is responsible for creating and returning instances of classes based on input arguments.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class AnimalFactory:
    def create_animal(self, animal_type):
        if animal_type == "Dog":
            return Dog()
        elif animal_type == "Cat":
            return Cat()
        else:
            return None
    \end{lstlisting}

    \item \textbf{Mixin Usage}: Create a mixin for JSON serialization of a Python object.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
import json

class JSONMixin:
    def to_json(self):
        return json.dumps(self.__dict__)
    \end{lstlisting}

    \item \textbf{Diamond Inheritance Problem}: Create a diamond inheritance structure and solve the method resolution order problem using `super()`.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class A:
    def method(self):
        print("A method")

class B(A):
    def method(self):
        print("B method")

class C(A):
    def method(self):
        print("C method")

class D(B, C):
    def method(self):
        super().method()

d = D()
d.method()  # Outputs: B method
    \end{lstlisting}

    \item \textbf{Observer Pattern}: Create a system where an object maintains a list of its dependents and notifies them of any state changes.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Observer:
    def update(self):
        pass

class Subject:
    def __init__(self):
        self._observers = []

    def add_observer(self, observer):
        self._observers.append(observer)

    def remove_observer(self, observer):
        self._observers.remove(observer)

    def notify(self):
        for observer in self._observers:
            observer.update()
    \end{lstlisting}

    \item \textbf{Decorator Pattern}: Implement a decorator pattern to add additional responsibilities to an object dynamically.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Coffee:
    def cost(self):
        return 5

class MilkDecorator:
    def __init__(self, coffee):
        self._coffee = coffee

    def cost(self):
        return self._coffee.cost() + 2
    \end{lstlisting}

    \item \textbf{Strategy Pattern}: Implement a strategy pattern where the algorithm can be selected at runtime.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Strategy:
    def execute(self):
        pass

class ConcreteStrategyA(Strategy):
    def execute(self):
        print("Strategy A")

class ConcreteStrategyB(Strategy):
    def execute(self):
        print("Strategy B")

class Context:
    def __init__(self, strategy):
        self._strategy = strategy

    def execute(self):
        self._strategy.execute()
    \end{lstlisting}

    \item \textbf{State Pattern}: Implement a pattern to allow an object to change its behavior when its internal state changes.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class State:
    def handle(self):
        pass

class StateA(State):
    def handle(self):
        print("State A handled")

class StateB(State):
    def handle(self):
        print("State B handled")

class Context:
    def __init__(self, state):
        self._state = state

    def request(self):
        self._state.handle()
    \end{lstlisting}

    \item \textbf{Prototype Pattern}: Implement the prototype pattern to clone objects.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
import copy

class Prototype:
    def clone(self):
        return copy.deepcopy(self)
    \end{lstlisting}

    \item \textbf{Chain of Responsibility Pattern}: Implement a pattern to pass a request along a chain of potential handlers until one of them handles the request.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Handler:
    def __init__(self, successor=None):
        self._successor = successor

    def handle(self, request):
        if self._successor:
            self._successor.handle(request)
    \end{lstlisting}

    \item \textbf{Multiple Interfaces}: Create a class that implements two distinct interfaces.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Walker:
    def walk(self):
        pass

class Swimmer:
    def swim(self):
        pass

class Amphibian(Walker, Swimmer):
    def walk(self):
        print("Walking")

    def swim(self):
        print("Swimming")
    \end{lstlisting}

    \item \textbf{Adapter Pattern}: Create a pattern that allows two incompatible interfaces to work together.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class OldSystem:
    def old_request(self):
        print("Old request")

class Adapter:
    def __init__(self, old_system):
        self._old_system = old_system

    def request(self):
        self._old_system.old_request()
    \end{lstlisting}

    \item \textbf{Proxy Pattern}: Implement a pattern to provide a surrogate for another object to control access to it.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class RealSubject:
    def request(self):
        print("Real request")

class Proxy:
    def __init__(self, real_subject):
        self._real_subject = real_subject

    def request(self):
        self._real_subject.request()
    \end{lstlisting}

    \item \textbf{Composite Pattern}: Implement a pattern to treat individual objects and compositions uniformly.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Component:
    def operation(self):
        pass

class Leaf(Component):
    def operation(self):
        print("Leaf operation")

class Composite(Component):
    def __init__(self):
        self._children = []

    def operation(self):
        for child in self._children:
            child.operation()

    def add(self, component):
        self._children.append(component)

    def remove(self, component):
        self._children.remove(component)
    \end{lstlisting}

    \item \textbf{Mediator Pattern}: Implement a pattern to centralize complex communications and control between related objects.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Mediator:
    def notify(self, sender, event):
        pass

class ConcreteMediator(Mediator):
    def __init__(self, component1, component2):
        self._component1 = component1
        self._component1.mediator = self
        self._component2 = component2
        self._component2.mediator = self

    def notify(self, sender, event):
        if event == "A":
            self._component2.react_on_a()
        elif event == "B":
            self._component1.react_on_b()
    \end{lstlisting}

    \item \textbf{Momento Pattern}: Implement a pattern to capture an object's internal state so that it can be restored later.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Momento:
    def __init__(self, state):
        self._state = state

    def get_state(self):
        return self._state

class Originator:
    _state = ""

    def set(self, state):
        self._state = state

    def save_to_momento(self):
        return Momento(self._state)

    def restore_from_momento(self, momento):
        self._state = momento.get_state()
    \end{lstlisting}

    \item \textbf{Flyweight Pattern}: Implement a pattern to minimize memory usage by sharing data between similar objects.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Flyweight:
    def operation(self, extrinsic_state):
        pass

class ConcreteFlyweight(Flyweight):
    _intrinsic_state = ""

    def operation(self, extrinsic_state):
        print(extrinsic_state + self._intrinsic_state)

class FlyweightFactory:
    _flyweights = {}

    def get_flyweight(self, key):
        if key not in self._flyweights:
            self._flyweights[key] = ConcreteFlyweight()
        return self._flyweights[key]
    \end{lstlisting}

    \item \textbf{Template Pattern}: Implement a pattern that defines the structure of an algorithm, but allows subclasses to override certain steps.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Algorithm:
    def step1(self):
        pass

    def step2(self):
        pass

    def template_method(self):
        self.step1()
        self.step2()

class ConcreteAlgorithm(Algorithm):
    def step1(self):
        print("Step 1")

    def step2(self):
        print("Step 2")
    \end{lstlisting}

    \item \textbf{Visitor Pattern}: Implement a pattern that lets you add further operations to objects without having to modify them.

    \textbf{Solution}:
    \begin{lstlisting}[language=Python]
class Visitor:
    def visit_concrete_element_a(self, element):
        pass

    def visit_concrete_element_b(self, element):
        pass

class ConcreteVisitor1(Visitor):
    def visit_concrete_element_a(self, element):
        print("Concrete visitor 1 for element A")

    def visit_concrete_element_b(self, element):
        print("Concrete visitor 1 for element B")

class Element:
    def accept(self, visitor):
        pass

class ConcreteElementA(Element):
    def accept(self, visitor):
        visitor.visit_concrete_element_a(self)

class ConcreteElementB(Element):
    def accept(self, visitor):
        visitor.visit_concrete_element_b(self)
    \end{lstlisting}
\end{enumerate}


\newpage
\newpage
\chapter{Turtle library}
\section{General operations on the Turtle pseudo object}
The Turtle library is a popular tool in Python used for creating simple graphics. It is especially suitable for beginner programmers because of its easy-to-understand syntax and interactive nature. The library creates a panel and pen that you can move around to create intricate designs.

The following is an example of how to use the Turtle library to draw a square:

\begin{Example}
\begin{lstlisting}
from turtle import *

# Move turtle
for _ in range(4):
    forward(100)
    right(90)

# Keep the window open
exitonclick()
\end{lstlisting}
\end{Example}

In the above code, we first import the turtle module. Then, we create a turtle screen with a white background. Next, we create a turtle object \textbf{my\_turtle}. In the for loop, the turtle moves forward by 100 units and then turns right by 90 degrees. This is repeated four times to complete a square. The `turtle.done()` line is used to keep the turtle graphics window open.

The Turtle library provides numerous other functionalities, such as changing the pen color, filling shapes with color, and much more, allowing users to create a wide range of graphics.
\section{Changing the pen color and filling shapes}

You can change the color of the pen in the Turtle library using the `color()` function. You can also fill shapes using the \textbf{begin\_fill()} and \textbf{end\_fill()} functions. Here is an example:

\begin{Example}
\begin{lstlisting}
from turtle import *

color("red")

begin_fill()
for _ in range(4):
    forward(100)
    right(90)
end_fill()

exitonclick()
\end{lstlisting}
\end{Example}

In the above code, we set the pen color to red using the \textbf{color()} function. Then, we use the \textbf{begin\_fill()} function before drawing the square and the \textbf{end\_fill()} function after drawing the square. This fills the square with the current pen color. 

\section{Changing the pen size}

You can change the pen size in the Turtle library using the \textbf{pensize()} function. Here is an example:

\begin{Example}
\begin{lstlisting}
from turtle import *

pensize(10)

for _ in range(4):
    forward(100)
    right(90)

exitonclick()
\end{lstlisting}
\end{Example}

In the above code, we set the pen size to 10 using the \textbf{pensize()} function. This makes the lines drawn by the turtle thicker.

\newpage
\chapter{Complex Python Programs}
In this section, we will present some more complex Python programs to demonstrate the power and flexibility of the language.

\section{Factorial Function}
Factorial of a non-negative integer n is the product of all positive integers less than or equal to n. It is denoted by n!.


Here's a Python function that calculates the factorial of a number using recursion:
\begin{Example}
\begin{lstlisting}[language=Python]
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)
\end{lstlisting}
\end{Example}

\section{Fibonacci Sequence}
The Fibonacci sequence is a sequence of numbers where the next number in the sequence is found by adding up the two numbers before it.


Here's a Python function that returns the n-th number in the Fibonacci sequence using recursion:
\begin{Example}
\begin{lstlisting}[language=Python]
def fibonacci(n):
    if n <= 1:
       return n
    else:
       return fibonacci(n-1) + fibonacci(n-2)
\end{lstlisting}
\end{Example}

\section{Factorial Function with Dynamic Programming}
By using dynamic programming techniques, we can optimize the calculation of the factorial by storing previously calculated values in a lookup table:

\begin{lstlisting}[language=Python]
def factorial(n, lookup={}):
    if n == 0 or n == 1:
        lookup[n] = 1

    # check if value already exists in lookup table
    if n not in lookup:
        lookup[n] = n * factorial(n-1)

    return lookup[n]
\end{lstlisting}

This approach ensures that each factorial is only calculated once and then stored in a dictionary for quick access.

\section{Fibonacci Sequence with Dynamic Programming}
Similarly, we can optimize the Fibonacci sequence calculation using dynamic programming to avoid recalculating the same values:

\begin{lstlisting}[language=Python]
def fibonacci(n, lookup={}):
    # Base case
    if n == 0 or n == 1:
        lookup[n] = n

    # If the value is not calculated previously, calculate it
    if n not in lookup:
        lookup[n] = fibonacci(n-1, lookup) + fibonacci(n-2, lookup)

    return lookup[n]
\end{lstlisting}

With dynamic programming, the above Fibonacci function will run significantly faster when called repeatedly or with large inputs, because it avoids the expensive computation of recalculating the Fibonacci sequence from scratch each time.

\section{Sorting Algorithm: Bubble Sort}
Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.


Here's a Python implementation of Bubble Sort:
\begin{Example}
\begin{lstlisting}[language=Python]
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
\end{lstlisting}
\end{Example}

\section{Prime Numbers}
A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.


Here's a Python function that checks if a number is prime:
\begin{Example}
\begin{lstlisting}[language=Python]
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True
\end{lstlisting}
\end{Example}

\newpage
\chapter{Data Structures in Python}

Python incorporates several built-in data structures for the efficient storage and manipulation of data, which include lists, tuples, sets, and dictionaries.

\section{Lists}
In Python, a list is an ordered collection of items which are not restricted to a specific type. Lists are defined by enclosing a comma-separated sequence of items within square brackets `[]`. Here is an illustrative example of a list in Python:
\begin{Example}
\begin{lstlisting}[language=Python]
fruits = ["apple", "banana", "cherry"]
\end{lstlisting}
\end{Example}
You can add an item to the list using the append() method, and remove an item using the remove() method:
\begin{Example}
\begin{lstlisting}[language=Python]
fruits.append("date")
fruits.remove("banana")
\end{lstlisting}
\end{Example}

\section{Tuples}
A tuple is akin to a list in terms of being an ordered collection of items, however, it is defined with parentheses `()` as opposed to square brackets. The principal difference lies in the fact that tuples are immutable. Here's an example:
\begin{Example}
\begin{lstlisting}[language=Python]
fruits = ("apple", "banana", "cherry")
\end{lstlisting}
\end{Example}
Accessing elements in a tuple is similar to accessing elements in a list:
\begin{Example}
\begin{lstlisting}[language=Python]
print(fruits[1])  # Output: "banana"
\end{lstlisting}
\end{Example}

\section{Sets}
A set in Python is characterized as an unordered collection of unique items. Sets are defined by enclosing a comma-separated list of items within curly braces `{}`. Here's an example of a set:
\begin{Example}
\begin{lstlisting}[language=Python]
fruits = {"apple", "banana", "cherry"}
\end{lstlisting}
\end{Example}
You can add an item to a set using the add() method, and remove an item using the remove() method:
\begin{Example}
\begin{lstlisting}[language=Python]
fruits.add("date")
fruits.remove("banana")
\end{lstlisting}
\end{Example}

\section{Dictionaries}
A dictionary in Python constitutes an unordered collection of items. Each item stored in a dictionary has a key and a corresponding value. The key can be utilized to access the related value. Dictionaries are defined by enclosing a comma-separated list of key-value pairs within curly braces `{}`. The key and value are separated by a colon `:`. Here's an example of a dictionary:
\begin{Example}
\begin{lstlisting}[language=Python]
person = {"name": "Alice", "age": 25}
\end{lstlisting}
\end{Example}
You can change the value of an item in a dictionary like this:
\begin{Example}
\begin{lstlisting}[language=Python]
person["age"] = 30
\end{lstlisting}
\end{Example}
You can add a new item to a dictionary like this:
\begin{Example}
\begin{lstlisting}[language=Python]
person["profession"] = "Engineer"
\end{lstlisting}
\end{Example}

\newpage
\begin{center}
 This page was left empty with accordance to author's hidden intention...
\end{center}
\newpage
\chapter{Projects and training with Tasks}
\section{Project 1}
\subsubsection{Project Description}

The task of this program is to create an interactive drawing application using the turtle module in Python. The program allows the user to control a turtle object on the screen and perform various actions. 

\subsubsection{Specification(may be modified by user as the task is creative one)}
Here is a breakdown of the tasks performed by the program:

\begin{enumerate}[label=\arabic*.]
  \item Set up the Turtle:
    \begin{itemize}
      \item Create a turtle object.
      \item Set the turtle's speed to 100.
      \item Set the turtle's initial color to red.
      \item Set the turtle's width to 1.
      \item Set the turtle's shape to "turtle".
      \item Put the turtle's pen down to start drawing.
    \end{itemize}
  
  \item Define Color Changing Functions:
    \begin{itemize}
      \item Implement \texttt{turtle\_color\_red()} to change the turtle's color to red.
      \item Implement \texttt{turtle\_color\_green()} to change the turtle's color to green.
    \end{itemize}
  
  \item Define Mouse Event Function:
    \begin{itemize}
      \item Implement \texttt{fxn(x, y)} to handle mouse drag events.
      \item Stop backtracking of the turtle.
      \item Adjust the turtle's angle and direction towards the new coordinates (x, y).
      \item Move the turtle to the new coordinates (x, y).
      \item Enable the function to be called again for further dragging.
    \end{itemize}
  
  \item Define Keyboard Event Functions:
    \begin{itemize}
      \item Implement \texttt{move\_forward()} to move the turtle forward by 50 units.
      \item Implement \texttt{move\_backward()} to move the turtle backward by 50 units.
      \item Implement \texttt{turn\_left()} to rotate the turtle left by 45 degrees.
      \item Implement \texttt{turn\_right()} to rotate the turtle right by 45 degrees.
      \item Implement \texttt{fill\_screen()} to fill the entire screen with color.
    \end{itemize}
  
  \item Set up Event Listeners:
    \begin{itemize}
      \item Get the turtle's screen object.
      \item Enable listening for key and mouse events.
      \item Register event handlers for specific keys and mouse clicks.
      \item When events occur, the corresponding functions are called to perform the desired actions.
    \end{itemize}
  
  \item Enter the Main Event Loop:
    \begin{itemize}
      \item Start the turtle's event loop.
      \item The program continuously listens for events and responds accordingly.
      \item The program remains interactive until the window is closed.
    \end{itemize}
\end{enumerate}

The main goal of this program is to provide an interactive drawing experience where the user can control the turtle's movement, change its color, and fill the screen with color. The program utilizes various event-driven functions to respond to user inputs and update the turtle's behavior on the screen.

\subsubsection{The one of possible solutions}
\begin{Example}
\begin{lstlisting}
from turtle import *
from random import randint
from time import sleep

t = Turtle()  # Create a turtle object
t.speed(100)  # Set the turtle's speed
t.color("red")  # Set the turtle's color
t.width(1)  # Set the turtle's width
t.shape("turtle")  # Set the turtle's shape
t.pendown()  # Put the turtle's pen down to start drawing

def turtle_color_red():
    t.color("red")  # Change the turtle's color to red

def turtle_color_green():
    t.color("green")  # Change the turtle's color to green

def fxn(x, y):
    t.ondrag(None)  # Stop backtracking
    t.setheading(t.towards(x, y))  # Move the turtle's angle and direction towards x and y
    t.goto(x, y)  # Go to x, y
    t.ondrag(fxn)  # Call the function again for further dragging

def move_forward():
    t.forward(50)  # Move the turtle forward by 50 units

def move_backward():
    t.backward(50)  # Move the turtle backward by 50 units

def turn_left():
    t.left(45)  # Turn the turtle left by 45 degrees

def turn_right():
    t.right(45)  # Turn the turtle right by 45 degrees

def fill_screen():
    t.begin_fill()  # Start filling the shape with color
    t.goto(-scr.window_width() / 2, -scr.window_height() / 2)  # Go to the bottom-left corner of the screen
    t.goto(scr.window_width() / 2, -scr.window_height() / 2)  # Go to the bottom-right corner of the screen
    t.goto(scr.window_width() / 2, scr.window_height() / 2)  # Go to the top-right corner of the screen
    t.goto(-scr.window_width() / 2, scr.window_height() / 2)  # Go to the top-left corner of the screen
    t.goto(-scr.window_width() / 2, -scr.window_height() / 2)  # Go back to the bottom-left corner of the screen
    t.end_fill()  # Stop filling the shape with color

t.speed(10)  # Set the turtle's speed
scr = t.getscreen()  # Get the turtle's screen
scr.listen()  # Enable listening for key and mouse events
scr.onkey(turtle_color_red, "r")  # Call turtle_color_red function when 'r' key is pressed
scr.onkey(turtle_color_green, "g")  # Call turtle_color_green function when 'g' key is pressed
scr.onkey(move_forward, "Up")  # Call move_forward function when 'Up' arrow key is pressed
scr.onkey(move_backward, "Down")  # Call move_backward function when 'Down' arrow key is pressed
scr.onkey(turn_left, "Left")  # Call turn_left function when 'Left' arrow key is pressed
scr.onkey(turn_right, "Right")  # Call turn_right function when 'Right' arrow key is pressed
scr.onclick(fxn)  # Call fxn function when the screen is clicked
scr.onkey(fill_screen, "f")  # Call fill_screen function when 'f' key is pressed
scr.mainloop()  # Start the turtle's event loop

\end{lstlisting}
\end{Example}
\newpage
\section{Project 2 specification}


\subsubsection{Task 1 (10 points)}
Construct a list of MIT classes in the following format (in this context, the list is not a data structure, but a simple enumeration of elements):

\begin{itemize}
\item Course 1 - Civil and Environmental Engineering
\item Course 2 - Mechanical Engineering
\item Course 3 - Materials Science and Engineering
\item Course 4 - Architecture
\item Course 5 - Chemistry
\item Course 6 - Electrical Engineering and Computer Science
\item Course 7 - Biology
\item Course 8 - Physics
\item Course 9 - Brain and Cognitive Sciences
\item Course 10 - Chemical Engineering
\end{itemize}

\textbf{Attention!} Employing the \texttt{.format} function will guarantee acquiring 5 points of task performance.

\subsubsection{Task 2 (10 points)}
Request a user to input a number of an integer in the range $[1, \dots, i, \dots, 10]$, where $i \in \mathbb{N}$, and $1 \leq i \leq 10$. Once the program receives the number from the user, it returns the name of the course corresponding to the given number. \\
\textbf{Example:} \\
\texttt{Program: Enter the number...} \\
\texttt{User:    1} \\
\texttt{Program: Course 1 - Civil and Environmental Engineering}

\subsubsection{Task 3 (10 points)}
Consider the fraction $\frac{a}{b} = \frac{nominator}{denominator}}$. In this task, ask the user to input the numerator and denominator values. The program should return the result and (if possible) the remainder of this division operation. For this task, create a variable used in a while loop called \texttt{i = a} and another variable called \texttt{answer}; while \texttt{i > 0}, let \texttt{i = i - b} and \texttt{answer = answer + 1}. If \texttt{i == 0}, the program should print the result as the value of the \texttt{str} function type in the following format: \texttt{"Result" + str(answer)}. If \texttt{i != 0}, the program prints \texttt{"Result"} as the \texttt{answer - 1} string value and then the program prints: \texttt{"Reminder:" + str(i+b)}. The names of any variables here in the task may be chosen by the student. Following this example for naming the variables may make the solution more readable for the grader.

\newpage
\section{Project 3 specification}
\subsubsection{Task 1 (10 points)}
Write a function \texttt{calculate\_the\_sum\_of\_n\_numbers(n)} which calculates the sum of $n$ numbers, where $n$ is a natural finite number. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_the_sum_of_n_numbers(100)
\end{lstlisting}
This will be used to calculate the sum $1 + 2 + 3 + \dots + 100 = \frac{100*101}{2} = 50*101 = 5050$.

\subsubsection{Task 2 (10 points)}
Write a function \texttt{nums\_to\_n(n)} to print all the odd numbers from 1 to $n$, where $n$ is a natural finite number, and if the number is divisible by 5, the function should draw the user's attention to it. The function does not return anything, it prints all odd numbers from 1 to $n$. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
nums_to_n(10)
\end{lstlisting}
This code should print:
\begin{verbatim}
1;
3;
5 is divisible by 5;
7;
9;
\end{verbatim}
Remember to include a semicolon at the end of each line!

\subsubsection{Task 3 (10 points)}
Write a function named \texttt{analyse\_the\_number(x, a\_less, b\_greater)} which will:
\begin{itemize}
\item Inform the user if the number is odd or even;
\item Inform the user if the number is greater than or equal to \texttt{"b\_greater"};
\item Inform the user if the number is less than or equal to \texttt{"a\_less"};
\item Tell the user what is the factorial of $x$: if $x = 6$, it will print $6*5*4*3*2*1$;
\item Print $(x^{b\_greater})^{a\_less}$;
\item If the number is from the set $[-2, 2]$ (the number $x$ may be $2$, $-1$, $0$, $1$, $2$), the function will print the number as follows: if the number $x$ is $2$, the program will print: "two".
\end{itemize}

\section{Specification of the Project 4}

\subsubsection{Task 1 (10 points)}
Write a function \texttt{calculate\_factorial(n)} that calculates and returns the factorial of a natural number $n$. This function should raise an exception if $n$ is negative or if it's not an integer. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_factorial(5)
\end{lstlisting}
This will return $5*4*3*2*1 = 120$.

\subsubsection{Task 2 (10 points)}
Write a function \texttt{print\_fibonacci(n)} that prints the first $n$ numbers in the Fibonacci sequence. The function should print each number on a new line. The function does not return anything, it only prints the Fibonacci numbers. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
print_fibonacci(7)
\end{lstlisting}
This code should print:
\begin{verbatim}
0
1
1
2
3
5
8
\end{verbatim}

\subsubsection{Task 3 (10 points)}
Write a function \texttt{is\_prime(n)} that returns \texttt{True} if a number is prime and \texttt{False} otherwise. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
is_prime(7)
\end{lstlisting}
This will return \texttt{True} because 7 is a prime number.

\newpage
\section{Specification of the Project 5}

\subsubsection{Task 1 (10 points)}
Write a function \texttt{read\_file(file\_name)} that reads a text file and returns a list where each element is a line in the file. This function should handle possible exceptions due to file handling issues. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
read_file('example.txt')
\end{lstlisting}
This function will read the text file 'example.txt' and return its contents as a list of strings.

\subsubsection{Task 2 (10 points)}
Write a function \texttt{find\_pattern(file\_name, pattern)} that uses regular expressions to find all occurrences of a specific pattern in a text file. This function should return a list of all matches. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
find_pattern('example.txt', r'\d+')
\end{lstlisting}
This function will find all sequences of digits in 'example.txt' and return them as a list.

\subsubsection{Task 3 (20 points)}
Write a function \texttt{web\_scrape(url, tag)} that uses BeautifulSoup to scrape a specific tag from a webpage. This function should return a list of strings, each of which corresponds to the inner content of one instance of the tag in the HTML of the webpage. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
web_scrape('https://example.com', 'h1')
\end{lstlisting}
This function will return the inner content of all 'h1' tags in the HTML of 'https://example.com'.
\newpage

\section{Specification of the Project 6}

\subsubsection{Task 1 (10 points)}
Write a function \texttt{is\_prime(n)} that checks whether a given integer $n$ is a prime number. The function should return \texttt{True} if the number is prime and \texttt{False} otherwise. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
is_prime(7)
\end{lstlisting}
This function will return \texttt{True}, as 7 is a prime number.

\subsubsection{Task 2 (15 points)}
Write a function \texttt{calculate\_factorial(n)} that calculates and returns the factorial of a number $n$. The function should raise an exception if $n$ is negative or not an integer. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_factorial(5)
\end{lstlisting}
This function will return $5*4*3*2*1 = 120$.

\subsubsection{Task 3 (15 points)}
Write a function \texttt{calculate\_combination(n, r)} that calculates and returns the combination of $n$ items taken $r$ at a time, where $n$ and $r$ are natural numbers and $r \leq n$. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_combination(5, 2)
\end{lstlisting}
This function will return $10$, as there are 10 ways to choose 2 items from 5.

\subsubsection{Task 4 (20 points)}
Write a function \texttt{calculate\_mean\_median(file\_name)} that reads a file containing a list of numbers, one per line, and returns a tuple containing the mean and median of these numbers. The function should handle possible exceptions due to file handling issues. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_mean_median('numbers.txt')
\end{lstlisting}
This function will return a tuple (mean, median) calculated from the numbers in the file 'numbers.txt'.

\subsubsection{Task 5 (20 points)}
Write a function \texttt{plot\_distribution(file\_name)} that reads a file containing a list of numbers and uses matplotlib to plot a histogram of the data. The function should handle possible exceptions due to file handling issues. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
plot_distribution('numbers.txt')
\end{lstlisting}
This function will read the numbers from the file 'numbers.txt' and display a histogram of the data.

\section{Specification of the Project 7}
\subsubsection{Task 1 (20 points)}
Define a Python class \texttt{Matrix} to represent a mathematical matrix. The class should include methods for matrix addition, matrix subtraction, matrix multiplication, and transpose of a matrix. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
matrix1 = Matrix([[1, 2], [3, 4]])
matrix2 = Matrix([[5, 6], [7, 8]])
print(matrix1.add(matrix2))
print(matrix1.subtract(matrix2))
print(matrix1.multiply(matrix2))
print(matrix1.transpose())
\end{lstlisting}
This should print the results of the matrix operations.

\subsubsection{Task 2 (20 points)}
Write a Python function \texttt{fibonacci(n)} that calculates the $n$th Fibonacci number using recursion. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
print(fibonacci(10))
\end{lstlisting}
This should print the 10th Fibonacci number.

\subsubsection{Task 3 (20 points)}
Write a Python function \texttt{simulate\_random\_walk(steps)} that simulates a one-dimensional random walk of a specified number of steps using NumPy and returns the final position. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
print(simulate_random_walk(1000))
\end{lstlisting}
This should print the final position of the random walk after 1000 steps.

\subsubsection{Task 4 (20 points)}
Write a Python function \texttt{plot\_random\_walk(steps)} that simulates a one-dimensional random walk of a specified number of steps and creates a plot of the walk using Matplotlib. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
plot_random_walk(1000)
\end{lstlisting}
This should display a plot of the random walk after 1000 steps.

\subsubsection{Task 5 (20 points)}
Write a Python function \texttt{simulate\_random\_walks(number\_of\_walks, steps)} that simulates a specified number of one-dimensional random walks of a specified number of steps each. The function should return the average final position and the standard deviation of the final positions of the walks. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
average, std_dev = simulate_random_walks(100, 1000)
print('Average:', average)
print('Standard Deviation:', std_dev)
\end{lstlisting}
This should print the average and standard deviation of the final positions of 100 random walks of 1000 steps each.
\newpage
\section{Specification of the Project 8}

\subsubsection{Task 1 (25 points)}
Write a Python function \texttt{solve\_quadratic(a, b, c)} that solves a quadratic equation of the form $ax^2 + bx + c = 0$. The function should return the roots of the equation. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
print(solve_quadratic(1, -3, 2))
\end{lstlisting}
This should print the roots of the equation $x^2 - 3x + 2 = 0$.

\subsubsection{Task 2 (25 points)}
Write a Python function \texttt{function\_analysis(f, x\_range)} that plots a given function $f(x)$ over a specified range of $x$ values, calculates the maximum and minimum of the function over that range, and integrates the function over that range. The function should use the matplotlib library for plotting and the scipy library for integration. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
import numpy as np
def f(x):
    return x**2
function_analysis(f, np.linspace(0, 1, 100))
\end{lstlisting}
This should plot the function $f(x) = x^2$ over the range from 0 to 1, print the maximum and minimum values over that range, and print the integral of $f(x)$ over that range.

\subsubsection{Task 3 (25 points)}
Write a Python function \texttt{solve\_system(A, b)} that solves a system of linear equations given by the matrix equation $Ax = b$. The function should use the numpy library to solve the equation. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])
print(solve_system(A, b))
\end{lstlisting}
This should print the solution to the system of equations $3x_1 + x_2 = 9$ and $x_1 + 2x_2 = 8$.

\subsubsection{Task 4 (25 points)}
Write a Python function \texttt{calculate\_derivative(f, x)} that calculates the derivative of a function at a given point. The function should use the scipy library to calculate the derivative. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
def f(x):
    return x**3
print(calculate_derivative(f, 2))
\end{lstlisting}
This should print the derivative of the function $f(x) = x^3$ at $x = 2$.
\newpage

\section{Specification of the Project 9}

\subsubsection{Task 1 (25 points)}
Write a Python function \texttt{polynomial\_coefficients(n)} that generates the coefficients of a polynomial of degree $n$. The coefficients should be random integers in the range from -10 to 10. The function should return a list of the coefficients. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
print(polynomial_coefficients(3))
\end{lstlisting}
This might print the list \texttt{[-2, 5, -10, 1]}, which corresponds to the polynomial $-2x^3 + 5x^2 - 10x + 1$.

\subsubsection{Task 2 (25 points)}
Write a Python function \texttt{polynomial\_value(coefs, x)} that calculates the value of a polynomial at a given point $x$. The coefficients of the polynomial are given as a list of numbers. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
coefs = [1, -3, 2]
x = 2
print(polynomial_value(coefs, x))
\end{lstlisting}
This should print the value of the polynomial $x^2 - 3x + 2$ at $x = 2$.

\subsubsection{Task 3 (25 points)}
Write a Python function \texttt{solve\_quadratic(coefs)} that solves a quadratic equation given by its coefficients. The coefficients are given as a list of three numbers. The function should return the roots of the equation. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
coefs = [1, -3, 2]
print(solve_quadratic(coefs))
\end{lstlisting}
This should print the roots of the quadratic equation $x^2 - 3x + 2 = 0$.

\subsubsection{Task 4 (25 points)}
Write a Python function \texttt{plot\_polynomial(coefs, x\_range)} that plots a polynomial given by its coefficients over a specified range of $x$ values. The coefficients are given as a list of numbers. The function should use the matplotlib library for plotting. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
coefs = [1, -3, 2]
x_range = np.linspace(-10, 10, 200)
plot_polynomial(coefs, x_range)
\end{lstlisting}
This should plot the polynomial $x^2 - 3x + 2$ over the range from -10 to 10.
\newpage
\section{Specification of the Project 10}

\subsubsection{Task 1 (20 points)}
Write a Python function \texttt{scrape\_webpage(url)} that takes in a URL of a webpage and scrapes the text content of that webpage using the BeautifulSoup library. The function should return a string of the webpage content. You must handle exceptions properly in your function to account for potential errors like network issues or invalid URLs.

\subsubsection{Task 2 (20 points)}
Extend the \texttt{scrape\_webpage(url)} function to now save the scraped webpage content into a .txt file. The filename should be based on the webpage's title.

\subsubsection{Task 3 (30 points)}
Write a Python function \texttt{count\_word\_frequency(text)} that takes in a string of text and counts the frequency of each word in that text. The function should ignore common stopwords (like 'a', 'the', 'and', etc.) and return a dictionary where the keys are words and the values are their respective frequencies.

\subsubsection{Task 4 (30 points)}
Write a Python function \texttt{plot\_word\_frequency(word\_frequency)} that takes in a dictionary of word frequencies (like the one produced by the \texttt{count\_word\_frequency(text)} function) and generates a bar chart of the top 10 most frequent words using matplotlib. The chart should have words on the x-axis and their frequencies on the y-axis.


\newpage
\chapter{Specification tasks "S"}

For this parf of tasks the user is supposed to use the testing functions included in the content of the book. All tasks are structured in the way that reaced should implement the function described in the specification for each task of the separate S training tasks.



\section{Task S1}

\subsubsection{Task 1 (10 points)}
Write a function \texttt{construct\_course\_list()} that constructs and returns a list of MIT classes in the following format:

\begin{itemize}
\item Course 1 - Civil and Environmental Engineering
\item Course 2 - Mechanical Engineering
\item Course 3 - Materials Science and Engineering
\item Course 4 - Architecture
\item Course 5 - Chemistry
\item Course 6 - Electrical Engineering and Computer Science
\item Course 7 - Biology
\item Course 8 - Physics
\item Course 9 - Brain and Cognitive Sciences
\item Course 10 - Chemical Engineering
\end{itemize}

\textbf{Returns:}
\begin{itemize}
\item \texttt{course\_list} (list): A list of strings representing the MIT course names.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Python]
construct_course_list()
\end{lstlisting}
This will return the following list:
\begin{verbatim}
[
"Course 1 - Civil and Environmental Engineering",
"Course 2 - Mechanical Engineering",
"Course 3 - Materials Science and Engineering",
"Course 4 - Architecture",
"Course 5 - Chemistry",
"Course 6 - Electrical Engineering and Computer Science",
"Course 7 - Biology",
"Course 8 - Physics",
"Course 9 - Brain and Cognitive Sciences",
"Course 10 - Chemical Engineering"
]
\end{verbatim}

\subsubsection{Task 2 (10 points)}
Write a function \texttt{get\_course\_name(number)} that takes a number as input and returns the name of the MIT course corresponding to the given number.

\textbf{Function Input:}
\begin{itemize}
\item \texttt{number} (int): The course number to retrieve the name for.
\end{itemize}

\textbf{Returns:}
\begin{itemize}
\item \texttt{course\_name} (str): The name of the MIT course corresponding to the given number.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Python]
get_course_name(1)
\end{lstlisting}
This will return the following string:
\begin{verbatim}
"Course 1 - Civil and Environmental Engineering"
\end{verbatim}


\subsubsection{Task 3 (10 points)}
Create a function that takes a day of the year (an integer from 1 to 365) as input and returns the corresponding month. You can assume a non-leap year. For simplicity, you can consider each month to have a fixed number of days as it has in the callendar (
    January: 31 days,
    February: 28 days(you has to consider this number in your solution) and 29 in every leap year,
    March: 31 days,
    April: 30 days,
    May: 31 days,
    June: 30 days,
    July: 31 days,
    August: 31 days,
    September: 30 days,
    October: 31 days,
    November: 30 days,
    December: 31 days,). The function should return the month as a string. You can choose the month names as per your preference.
\textbf{Example:}
\begin{lstlisting}[language=Python]
print(get_month(75))  # Output: March
\end{lstlisting}


\subsubsection{Task 4 (10 points)}
Create a function \texttt{perform\_operation(a, b, c=0, d=0, e=0, f=0, g=0, h=0, i=0, operator='+')} that takes two numbers (\texttt{a} and \texttt{b}) and up to eight additional numbers (\texttt{c} to \texttt{i}) as arguments. The function should also accept an operator (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}) as a keyword argument. The function should perform the corresponding operation on all the provided numbers and return the result. If the operator is division (\texttt{/}) and the second number is zero, the function should return an error message.

\textbf{Function Inputs:}
\begin{itemize}
\item \texttt{a} (numeric): The first number.
\item \texttt{b} (numeric): The second number.
\item \texttt{c} to \texttt{i} (numeric, optional): Up to eight additional numbers.
\item \texttt{operator} (str, optional): The operator to perform the operation. Default is \texttt{'+'}.
\end{itemize}

\textbf{Returns:}
\begin{itemize}
\item \texttt{result} (numeric or str): The result of the operation. If the operator is division (\texttt{/}) and the second number is zero, return the error message: \texttt{"Error: Division by zero"}.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Python]
print(perform_operation(5, 3, 2, 4, operator='+')) # Output: 14
print(perform_operation(10, 2, 3, operator='*')) # Output: 60
print(perform_operation(5, 0, operator='/')) # Output: "Error: Division by zero"
\end{lstlisting}

Note: The specific implementation details and variable names may vary.

\subsubsection{Task 5 (10 points)}
Consider the fraction $\frac{a}{b} = \frac{nominator}{denominator}$, where $a$ represents the numerator and $b$ represents the denominator. In this task, ask the user to input the numerator and denominator values. The program should calculate the result of the division and (if possible) the remainder of the division operation.

Create a function \texttt{divide\_fraction(numerator, denominator)} that takes the numerator and denominator as input and returns the division result and remainder (if applicable).

Within the function, create a variable \texttt{i} and set it equal to \texttt{numerator}, and create another variable \texttt{answer} and set it to 0.

Use a while loop to iterate while \texttt{i} is greater than 0. In each iteration, subtract the \texttt{denominator} from \texttt{i} and increment \texttt{answer} by 1.

If \texttt{i} becomes 0 after the loop, return a string in the format: "Result: \texttt{answer}".

If \texttt{i} is not 0, return a string in the format: "Result: \texttt{answer-1} \textbackslash n Reminder: \texttt{i+denominator}".

Feel free to choose your own variable names for this task.

\textbf{Function Inputs:}
\begin{itemize}
\item \texttt{numerator} (int): The numerator of the fraction.
\item \texttt{denominator} (int): The denominator of the fraction.
\end{itemize}

\textbf{Returns:}
\begin{itemize}
\item \texttt{result} (str): A string containing the division result and remainder (if applicable) in the format mentioned above.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Python]
divide_fraction(7, 3)
\end{lstlisting}
This will return the following string:
\begin{verbatim}
"Result: 2
 Reminder: 1"
\end{verbatim}
Maybe the usage of the \texttt{\textbackslash n} will help.

Note: The specific implementation details and variable names may vary.

\newpage
\section{Task S2}
\subsubsection{Task 1 (10 points)}
Write a function \texttt{calculate\_the\_sum\_of\_n\_numbers(n)} which calculates the sum of $n$ numbers, where $n$ is a natural finite number. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_the_sum_of_n_numbers(100)
\end{lstlisting}
This will be used to calculate the sum $1 + 2 + 3 + \dots + 100 = \frac{100*101}{2} = 50*101 = 5050$.

\subsubsection{Task 2 (10 points)}
Write a function \texttt{nums\_to\_n(n)} to print all the odd numbers from 1 to $n$, where $n$ is a natural finite number, and if the number is divisible by 5, the function should draw the user's attention to it. The function does not return anything, it prints all odd numbers from 1 to $n$. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
nums_to_n(10)
\end{lstlisting}
This code should print:
\begin{verbatim}
1;
3;
5 is divisible by 5;
7;
9;
\end{verbatim}
Remember to include a semicolon at the end of each line!

\subsubsection{Task 3 (10 points)}
Write a function named \texttt{analyse\_the\_number(x, a\_less, b\_greater)} which will:
\begin{itemize}
\item Inform the user if the number is odd or even;
\item Inform the user if the number is greater than or equal to \texttt{"b\_greater"};
\item Inform the user if the number is less than or equal to \texttt{"a\_less"};
\item Tell the user what is the factorial of $x$: if $x = 6$, it will print $6*5*4*3*2*1$;
\item Print the number$(x^{b\_greater})^{a\_less}$;
\item If the number is from the set $[-2, 2]$ (the number $x$ may be $2$, $-1$, $0$, $1$, $2$), the function will print the number as follows: if the number $x$ is $2$, the program will print: "two".
\end{itemize}

\subsubsection{Task 4 (10 points)}


Solve the following system of linear equations:

\[
\begin{align*}
2x + 3y &= 7 \\
4x - 2y &= 10 \\
\end{align*}
\]

Write a function \texttt{solve\_system(a1, b1, c1, a2, b2, c2)} that takes the coefficients of two linear equations of the form $a_1x + b_1y = c_1$ and $a_2x + b_2y = c_2$ as inputs and solves the system of equations. The function should return the solution as a tuple $(x, y)$ representing the values of $x$ and $y$ that satisfy both equations. If the system of equations has no solution or infinite solutions, return "No unique solution".

\textbf{Example:}
\begin{lstlisting}[language=Python]
solve_system(2, 3, 7, 4, -2, 10) # Output: (2.0, 1.0)
\end{lstlisting}

\begin{lstlisting}[language=Python]
solve_system(1, -2, 3, 2, -4, 6) # Output: "No unique solution"
\end{lstlisting}

\begin{lstlisting}[language=Python]
solve_system(1, 2, 3, 2, 4, 6) # Output: "No unique solution"
\end{lstlisting}

\begin{lstlisting}[language=Python]
solve_system(0, 0, 0, 0, 0, 0) # Output: "No unique solution"
\end{lstlisting}

\textbf{Note:} Show all the necessary steps and explanations to justify your solutions. You may use any appropriate methods or techniques taught in secondary school mathematics.

\subsubsection{Task 5 (10 points)}
Write a Python function \texttt{is\_palindrome(s)} that takes a string \texttt{s} as input and returns \texttt{True} if the string is a palindrome and \texttt{False} otherwise. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.

\textbf{Example:}
\begin{lstlisting}[language=Python]
is_palindrome("racecar") # Output: True
\end{lstlisting}


\begin{lstlisting}[language=Python]
is_palindrome("Hello, World!") # Output: False
\end{lstlisting}


Write the function \texttt{is\_palindrome} to solve the task and test it with different strings.



\newpage
\section{Task S3}

\subsubsection{Task 1 (10 points)}
Write a function \texttt{calculate\_factorial(n)} that calculates and returns the factorial of a natural number $n$. This function should raise an exception if $n$ is negative or if it's not an integer. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_factorial(5) # Output: 120
\end{lstlisting}
This will return $5*4*3*2*1 = 120$.

\subsubsection{Task 2 (10 points)}
Write a function \texttt{print\_fibonacci(n)} that prints the first $n$ numbers in the Fibonacci sequence. The function should print each number on a new line. The function does not return anything, it only prints the Fibonacci numbers. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
print_fibonacci(7)
\end{lstlisting}
This code should print:
\begin{verbatim}
0
1
1
2
3
5
8
\end{verbatim}

\subsubsection{Task 3 (10 points)}
Write a function \texttt{is\_prime(n)} that returns \texttt{True} if a number is prime and \texttt{False} otherwise. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
is_prime(7)
\end{lstlisting}
This will return \texttt{True} because 7 is a prime number.

\subsubsection{Task 4 (10 points)}
Write a function \texttt{find\_palindromes(words)} that takes a list of words and returns a new list containing only the palindromes from the original list. A palindrome is a word that reads the same forwards and backwards. The function should ignore case sensitivity, meaning "Mom" and "mOm" should be considered palindromes.

\textbf{Example:}
\begin{lstlisting}[language=Python]
words = ["level", "deed", "hello", "Madam", "world"]
find_palindromes(words)
\end{lstlisting}
This will return \texttt{["level", "deed", "Madam"]}, as these words are palindromes.

\subsubsection{Task 5 (10 points)}
Write a function \texttt{calculate\_mean(numbers)} that takes a list of numbers and returns the mean (average) value. The function should return the mean as a floating-point number.

\textbf{Example:}
\begin{lstlisting}[language=Python]
numbers = [1, 2, 3, 4, 5]
calculate_mean(numbers) # Output: 3.0
\end{lstlisting}
This will return the mean of the numbers in the list, which is 3.0.


\newpage

\section{Task S4}

\subsubsection{Task 1 (10 points)}
Write a function \texttt{calculate\_poly\_function\_val(a, b, c, d, e, k, g)} that calculates the value of a function $f(a, b, c, d, e, k, g) = 10a^3 + 11b^{10} + 12c^3 + 3d^2 + 6e^{18} + 67k^{12} + 22g^4 + \frac{127}{168}a^4 + 4e + \frac{6}{7}g^2 + \sqrt[3]{\frac{3}{2}a^2} - \frac{2}{5}d + 10e^2 - \pi k + \frac{(c + d + k + g)a^2}{b}$ at the given point $(a, b, c, d, e, k, g)$.

\textbf{Function Inputs:}
\begin{itemize}
\item \texttt{a} (float): The value of the variable $a$.
\item \texttt{b} (float): The value of the variable $b$.
\item \texttt{c} (float): The value of the variable $c$.
\item \texttt{d} (float): The value of the variable $d$.
\item \texttt{e} (float): The value of the variable $e$.
\item \texttt{f} (float): The value of the variable $k$.
\item \texttt{g} (float): The value of the variable $g$.
\end{itemize}

\textbf{Returns:}
\begin{itemize}
\item \texttt{result} (float): The calculated value of the function $f(a, b, c, d, e, k, g)$ at the given point.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_poly_function_val(1.5, 2.3, -0.7, 4.2, 0.8, -1.1, 3.6)
\end{lstlisting}
This will return the calculated value of the function at the given point.

Note: Make sure to handle any necessary mathematical operations correctly according to the specified function.

\subsubsection{Task 2 (10 points)}
Write a function \texttt{calculate\_factorial(n)} that calculates and returns the factorial of a number $n$. The function should raise an exception if $n$ is negative or not an integer. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_factorial(5)
\end{lstlisting}
This function will return $5*4*3*2*1 = 120$.

\subsubsection{Task 3 (10 points)}
Write a function \texttt{calculate\_combination(n, r)} that calculates and returns the combination of $n$ items taken $r$ at a time, where $n$ and $r$ are natural numbers and $r \leq n$. More presize information about the Newtonian binomial symbol defined to tel how many ways exists to choose r different items from n is below \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
calculate_combination(5, 2)
\end{lstlisting}
This function will return $10$, as there are 10 ways to choose 2 items from 5.

The combination, denoted as $\binom{n}{r}$, represents the number of ways to choose $r$ items from a set of $n$ distinct items, without regard to their order. It can be calculated using the formula:

\[
\binom{n}{r} = \frac{n!}{r!(n-r)!}
\]

\subsubsection{Task 4 (10 points)}

Write a function \texttt{analyze\_apple\_weights(apple\_weights)} that takes a list of apple weights as input and performs the following analysis:

    Calculate the average weight of the apples.
    Determine the maximum weight among the apples.
    Determine the minimum weight among the apples.

The function should return a dictionary containing the analysis results.

\textbf{Function Input:}
\begin{itemize}
\item \texttt{apple\_weights} (list): A list of floating-point numbers representing the weights of the apples.
\end{itemize}

\textbf{Returns:}
\begin{itemize}
\item \texttt{analysis\_results} (dictionary): A dictionary containing the following analysis results:
- \texttt{"average\_weight"}: The average weight of the apples.
- \texttt{"max\_weight"}: The maximum weight among the apples.
- \texttt{"min\_weight"}: The minimum weight among the apples.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Python]
apple_weights = [0.2, 0.5, 0.3, 0.6, 0.4]
analyze_apple_weights(apple_weights)
\end{lstlisting}
This will return the following dictionary:
\begin{verbatim}
{
"average_weight": 0.4,
"max_weight": 0.6,
"min_weight": 0.2
}
\end{verbatim}

Note: This simplified task focuses on calculating the average, maximum, and minimum weights of the apples in the dataset. It omits the additional analysis requirements mentioned in the original task.

\subsubsection{Task 5 (10 points)}
Consider the list of MIT classes in the following format:

\begin{itemize}
\item Course 1 - Civil and Environmental Engineering
\item Course 2 - Mechanical Engineering
\item Course 3 - Materials Science and Engineering
\item Course 4 - Architecture
\item Course 5 - Chemistry
\item Course 6 - Electrical Engineering and Computer Science
\item Course 7 - Biology
\item Course 8 - Physics
\item Course 9 - Brain and Cognitive Sciences
\item Course 10 - Chemical Engineering
\end{itemize}

Write a function \texttt{get\_course\_name(number)} that takes a number as input and returns the name of the MIT course corresponding to the given number.

\textbf{Function Input:}
\begin{itemize}
\item \texttt{number} (int): The course number to retrieve the name for.
\end{itemize}

\textbf{Returns:}
\begin{itemize}
\item \texttt{course\_name} (str): The name of the MIT course corresponding to the given number.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Python]
get_course_name(1)
\end{lstlisting}
This will return the following string:
\begin{verbatim}
"Course 1 - Civil and Environmental Engineering"
\end{verbatim}
\newpage
\section{Task S5}

\subsubsection{Task 1 (10 points)}
Create a function \texttt{perform\_operation(a, b, c=0, d=0, e=0, f=0, g=0, h=0, i=0, operator='+')} that takes two numbers (\texttt{a} and \texttt{b}) and up to eight additional numbers (\texttt{c} to \texttt{i}) as arguments. The function should also accept an operator (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}) as a keyword argument. The function should perform the corresponding operation on all the provided numbers and return the result. If the operator is division (\texttt{/}) and the second number is zero, the function should return an error message.

\textbf{Function Inputs:}
\begin{itemize}
\item \texttt{a} (numeric): The first number.
\item \texttt{b} (numeric): The second number.
\item \texttt{c} to \texttt{i} (numeric, optional): Up to eight additional numbers.
\item \texttt{operator} (str, optional): The operator to perform the operation. Default is \texttt{'+'}.
\end{itemize}

\textbf{Returns:}
\begin{itemize}
\item \texttt{result} (numeric or str): The result of the operation. If the operator is division (\texttt{/}) and the second number is zero, return the error message: \texttt{"Error: Division by zero"}.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Python]
print(perform_operation(5, 3, 2, 4, operator='+')) # Output: 14
print(perform_operation(10, 2, 3, operator='*')) # Output: 60
print(perform_operation(5, 0, operator='/')) # Output: "Error: Division by zero"
\end{lstlisting}

Note: The specific implementation details and variable names may vary.

\subsubsection{Task 2 (10 points)}
Write a Python function \texttt{fibonacci(n)} that calculates the $n$th Fibonacci number using recursion. \\
\textbf{Example:}
\begin{lstlisting}[language=Python]
print(fibonacci(10))
\end{lstlisting}
This should print the 10th Fibonacci number.

\subsubsection{Task 3 (10 points)}

Let's calculate the value of the iterated integral of a differentiable and continuous function $f(x,y,x) = 1$ :
\[
\int_a^b \int_c^d \int_e^g 1 \, dx \, dy \, dz = (b - a)(d - c)(g - e)
\]

Write a function \texttt{calculate\_iterated\_integral(a, b, c, d, e, g)} that calculates the value of the iterated integral of a differentiable and continuous function $f(x,y,z)=1$. The function should take the limits of integration aaa, bbb, ccc, ddd, eee, and ggg as inputs and return the calculated value of the iterated integral.

\textbf{Function Inputs:}
\begin{itemize}
\item \texttt{a} (numeric): The lower limit of integration for the variable xxx.
\item \texttt{b} (numeric): The upper limit of integration for the variable xxx.
\item \texttt{c} (numeric): The lower limit of integration for the variable yyy.
\item \texttt{d} (numeric): The upper limit of integration for the variable yyy.
\item \texttt{e} (numeric): The lower limit of integration for the variable zzz.
\item \texttt{g} (numeric): The upper limit of integration for the variable zzz.
\end{itemize}

\textbf{Returns:}
\begin{itemize}
\item \texttt{result} (numeric): The calculated value of the iterated integral, which is equal to $(b - a)(d - c)(g - e)$.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Python]
result = calculate_iterated_integral(1, 3, 2, 4, 0, 5)
print(result) # Output: 36
\end{lstlisting}

Note: The specific implementation details, function name, and variable names may vary.


\subsubsection{Task 4 (10 points)}
Write a Python function \texttt{is\_palindrome(s)} that takes a string \texttt{s} as input and returns \texttt{True} if the string is a palindrome and \texttt{False} otherwise. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.

\textbf{Example:}
\begin{lstlisting}[language=Python]
is_palindrome("racecar") # Output: True
\end{lstlisting}


\begin{lstlisting}[language=Python]
is_palindrome("Hello, World!") # Output: False
\end{lstlisting}


Write the function \texttt{is\_palindrome} to solve the task and test it with different strings.



\subsubsection{Task 5 (10 points)}
Create a function that takes a day of the year (an integer from 1 to 365) as input and returns the corresponding month. You can assume a non-leap year. For simplicity, you can consider each month to have a fixed number of days. The function should return the month as a string. You can choose the month names as per your preference.
\textbf{Example:}
\begin{lstlisting}[language=Python]
print(get_month(75))  # Output: March
\end{lstlisting}


\newpage


\chapter{Additional "P" tasks for mini-projects}

This section is more like the projects' tasks before the separate section with the specification tasks driven with testing functions. 

\section{Project 1: Turtle drawing }
\subsubsection{Description}

The task of this program is to create an interactive drawing application using the turtle module in Python. The program allows the user to control a turtle object on the screen and perform various actions. 

\subsubsection{Specification}
Here is a breakdown of the tasks performed by the program:

\begin{enumerate}[label=\arabic*.]
  \item Set up the Turtle:
    \begin{itemize}
      \item Create a turtle object.
      \item Set the turtle's speed to 100.
      \item Set the turtle's initial color to red.
      \item Set the turtle's width to 1.
      \item Set the turtle's shape to "turtle".
      \item Put the turtle's pen down to start drawing.
    \end{itemize}
  
  \item Define Color Changing Functions:
    \begin{itemize}
      \item Implement \texttt{turtle\_color\_red()} to change the turtle's color to red.
      \item Implement \texttt{turtle\_color\_green()} to change the turtle's color to green.
    \end{itemize}
  
  \item Define Mouse Event Function:
    \begin{itemize}
      \item Implement \texttt{fxn(x, y)} to handle mouse drag events.
      \item Stop backtracking of the turtle.
      \item Adjust the turtle's angle and direction towards the new coordinates (x, y).
      \item Move the turtle to the new coordinates (x, y).
      \item Enable the function to be called again for further dragging.
    \end{itemize}
  
  \item Define Keyboard Event Functions:
    \begin{itemize}
      \item Implement \texttt{move\_forward()} to move the turtle forward by 50 units.
      \item Implement \texttt{move\_backward()} to move the turtle backward by 50 units.
      \item Implement \texttt{turn\_left()} to rotate the turtle left by 45 degrees.
      \item Implement \texttt{turn\_right()} to rotate the turtle right by 45 degrees.
      \item Implement \texttt{fill\_screen()} to fill the entire screen with color.
    \end{itemize}
  
  \item Set up Event Listeners:
    \begin{itemize}
      \item Get the turtle's screen object.
      \item Enable listening for key and mouse events.
      \item Register event handlers for specific keys and mouse clicks.
      \item When events occur, the corresponding functions are called to perform the desired actions.
    \end{itemize}
  
  \item Enter the Main Event Loop:
    \begin{itemize}
      \item Start the turtle's event loop.
      \item The program continuously listens for events and responds accordingly.
      \item The program remains interactive until the window is closed.
    \end{itemize}
\end{enumerate}

The main goal of this program is to provide an interactive drawing experience where the user can control the turtle's movement, change its color, and fill the screen with color. The program utilizes various event-driven functions to respond to user inputs and update the turtle's behavior on the screen.
\newpage
\section{Project 2: Number Guessing Game}

\subsubsection{Description}
In this project, you will create a number guessing game. The program will generate a random number between a specified range, and the user will have to guess the number within a certain number of attempts. After each guess, the program will provide feedback to the user if the guess is too high or too low. The game will continue until the user guesses the correct number or runs out of attempts.

\subsubsection{Specifications}
\begin{itemize}
\item The program should generate a random number between a specified range.
\item The user should be prompted to enter their guess.
\item The program should provide feedback to the user if the guess is too high or too low.
\item The program should keep track of the number of attempts.
\item The game should continue until the user guesses the correct number or runs out of attempts.
\item The program should display a message indicating whether the user won or lost the game.
\end{itemize}

\newpage
\section{Project 3: To-Do List}

\subsubsection{Description}
In this project, you will create a simple to-do list application. The program will allow the user to add tasks, mark tasks as completed, and view the list of tasks. The tasks will be stored in memory while the program is running, and they will be lost once the program is closed.

\subsubsection{Specifications}
\begin{itemize}
\item The program should provide a menu with options to add a task, mark a task as completed, and view the list of tasks.
\item The user should be able to enter the details of a task (e.g., task name, due date) when adding a task.
\item The program should store the tasks in a list or data structure.
\item The program should display the list of tasks with their details.
\item The user should be able to mark a task as completed, which will update its status in the list.
\item The program should handle invalid inputs and provide appropriate error messages.
\end{itemize}

\newpage

\section{Project 4: Simple Calculator}

\subsubsection{Description}
In this project, you will create a simple calculator program. The program will prompt the user to enter two numbers and an operation (+, -, *, /), and it will perform the corresponding calculation and display the result.

\subsubsection{Specifications}
\begin{itemize}
\item The program should prompt the user to enter the first number.
\item The program should prompt the user to enter the second number.
\item The program should prompt the user to enter the operation (+, -, *, /).
\item The program should perform the corresponding calculation based on the entered numbers and operation.
\item The program should display the result of the calculation.
\item The program should handle invalid inputs and provide appropriate error messages.
\end{itemize}

\newpage


\section{Project 5: Hangman Game}

\subsubsection{Description}
In this project, you will create a Hangman game. The program will select a random word from a predefined list, and the user will have to guess the letters of the word one by one. The user will have a limited number of attempts, and the program will provide feedback on the correctness of each guess.

\subsubsection{Specifications}
\begin{itemize}
\item The program should select a random word from a predefined list of words.
\item The program should display the initial state of the word with underscores for the unknown letters.
\item The program should prompt the user to enter a letter guess.
\item The program should check the correctness of the guess and update the state of the word accordingly.
\item The program should display the updated state of the word with the correctly guessed letters.
\item The program should keep track of the number of attempts and limit the guesses to a certain number.
\item The program should display a message indicating whether the user won or lost the game.
\end{itemize}
\newpage



\chapter{Additional references}

\section{Manual Number Base Conversion}

If you don't have access to a computer or programming language, you can still manually convert numbers between different bases using pen and paper. Here's a step-by-step guide to manually convert numbers between binary, decimal, and hexadecimal bases:

\subsection{Binary to Decimal Conversion}

To convert a binary number to decimal manually, follow these steps:

\begin{enumerate}
\item Write down the binary number.
\item Start from the rightmost digit and assign powers of 2 to each digit, starting from 0 for the rightmost digit.
\item Multiply each digit by its corresponding power of 2.
\item Sum up the results to obtain the decimal equivalent.
\end{enumerate}

For example, let's convert the binary number $10101$ to decimal:

\begin{align*}
& \text{Binary number:} & 1 & 0 & 1 & 0 & 1 \\
& \text{Powers of 2:} & 2^4 & 2^3 & 2^2 & 2^1 & 2^0 \\
& \text{Multiplication:} & 16 & 0 & 4 & 0 & 1 \\
& \text{Sum:} & 2^4*1 + 2^3*0 + 2^2*1 + 2^1*0 + 2^0*1 = 21
\end{align*}

Therefore, the binary number $10101$ is equivalent to the decimal number $21$.

\subsection{Decimal to Binary Conversion}

To convert a decimal number to binary manually, follow these steps:

\begin{enumerate}
\item Write down the decimal number.
\item Divide the number by 2 and write down the quotient and remainder.
\item Repeat the division process with the quotient until the quotient becomes 0.
\item The binary representation is obtained by reading the remainders from the last division in reverse order.
\end{enumerate}

For example, let's convert the decimal number $21$ to binary:

\begin{table}[h]
\centering
\caption{Decimal to Binary Conversion}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Step} & \textbf{Division} & \textbf{Result} \\
\hline
Step 1 & 21 & \\
\hline
Step 2 & $21 \div 2 = 10$ & Quotient: 10, Remainder: 1 \\
\hline
Step 3 & $10 \div 2 = 5$ & Quotient: 5, Remainder: 0 \\
\hline
Step 4 & $5 \div 2 = 2$ & Quotient: 2, Remainder: 1 \\
\hline
Step 5 & $2 \div 2 = 1$ & Quotient: 1, Remainder: 0 \\
\hline
Step 6 & $1 \div 2 = 0$ & Quotient: 0, Remainder: 1 \\
\hline
\end{tabular}
\end{table}

Binary representation (reading remainders in reverse order): 10101


Therefore, the decimal number $21$ is equivalent to the binary number $10101$.

\subsection{Decimal to Hexadecimal Conversion}

To convert a decimal number to hexadecimal manually, follow these steps:

\begin{enumerate}
\item Write down the decimal number.
\item Divide the number by 16 and write down the quotient and remainder.
\item Repeat the division process with the quotient until the quotient becomes 0.
\item The hexadecimal representation is obtained by reading the remainders from the last division in reverse order. Replace any remainders greater than 9 with the corresponding hexadecimal letters: A for 10, B for 11, C for 12, D for 13, E for 14, and F for 15.
\end{enumerate}

For example, let's convert the decimal number $21$ to hexadecimal:

\begin{table}[h]
\centering
\caption{Decimal to Hexadecimal Conversion}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Step} & \textbf{Division} & \textbf{Result} \\
\hline
Step 1 & 21 & \\
\hline
Step 2 & $21 \div 16 = 1$ & Quotient: 1, Remainder: 5 \\
\hline
Step 3 & $1 \div 16 = 0$ & Quotient: 0, Remainder: 1 \\
\hline
\end{tabular}
\end{table}

Hexadecimal representation (reading remainders in reverse order): 15

Therefore, the decimal number $21$ is equivalent to the hexadecimal number $15$.

By following these manual conversion steps, you can convert numbers between binary, decimal, and hexadecimal bases without the need for a computer or programming language.

\section{A Deep Dive into the Quadratic Equation}

In the discipline of algebra, a preeminent form of a polynomial equation is the second-order polynomial equation, more commonly known as the quadratic equation. A polynomial function of a single variable $x$ is typically expressed in the following general form:

\begin{equation}
f(x) = \sum_{i=0}^{n} a_ix^i = a_0 + a_1x + a_2x^2 + \cdots + a_{n-1}x^{n-1} + a_nx^n \\,
\end{equation}
where the $f: \mathbb{R} \rightarrow \mathbb{R}$ or generally $f: \mathbb{C} \rightarrow \mathbb{C}$, $a_i, \ i \in \mathbb{N}, i \in \{0, 1, ..., n \}$ are constants and they are known as the coefficients of the polynomial. The power $n$ is a nonnegative integer and is called the degree of the polynomial. The coefficient $a_n$ of the highest power is called the leading coefficient.

 The standard form of second order equation is typically expressed as $ax^2 + bx + c = 0$, where $a$, $b$, and $c$ are constants that are defined such that $a \neq 0$. The coefficients $a$, $b$, and $c$ are often referred to as the quadratic, linear, and constant terms, respectively. 

The problem is: find the values of the f domain, such that f(x) = 0, f defined in $(1)$. An essential concept in the examination of these quadratic equations is the quadratic formula, which is universally used to calculate the roots of the equation. The quadratic formula is stated as:
\begin{equation}
x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}
\end{equation}
An interesting feature of the quadratic formula is the term under the square root, $b^2 - 4ac$. This term is known as the discriminant. It plays a pivotal role in determining the nature of the solutions to the quadratic equation.

\begin{itemize}
    \item If the discriminant is positive, the equation possesses two distinct real roots.
    \item If the discriminant equals zero, the equation has one real root, often referred to as a repeated or double root.
    \item If the discriminant is negative, the equation gives rise to two complex roots.
\end{itemize}

Consider, for instance, the quadratic equation $x^2 - 5x + 6 = 0$. The coefficients of this equation are $a=1$, $b=-5$, and $c=6$. By calculating the discriminant, we find $(-5)^2 - 4*1*6 = 25 - 24 = 1$. As this is a positive value, we infer that the equation has two distinct real roots. By substituting the coefficients into the quadratic formula, we find the solutions to be:

\[x = \frac{-(-5) \pm \sqrt{(-5)^2 - 4*1*6}}{2*1} = \frac{5 \pm 1}{2}\]

Therefore, the roots of the equation are $x = \frac{5 + 1}{2} = 3$ and $x = \frac{5 - 1}{2} = 2$. The study of quadratic equations and their solutions is a fundamental part of algebra, and it underlies many of the more advanced topics in mathematics.
\section{Solving Second Order Equations}

A second order equation, also known as a quadratic equation, is an equation of the form $ax^2 + bx + c = 0$, where $a$, $b$, and $c$ are constants, and $a \neq 0$. 

The solutions to a quadratic equation are given by the quadratic formula $(2)$:

The term under the square root, $b^2 - 4ac$, is known as the discriminant. It determines the nature of the roots of the quadratic equation.

\begin{itemize}
    \item If the discriminant is positive, the equation has two distinct real roots.
    \item If the discriminant is zero, the equation has exactly one real root (or a repeated real root).
    \item If the discriminant is negative, the equation has two complex roots.
\end{itemize}

For example, let's solve the equation $x^2 - 5x + 6 = 0$. Here $a=1$, $b=-5$, and $c=6$. The discriminant is $(-5)^2 - 4*1*6 = 25 - 24 = 1$, which is positive. Thus the equation has two distinct real roots. Applying the quadratic formula gives:

\[x = \frac{-(-5) \pm \sqrt{(-5)^2 - 4*1*6}}{2*1} = \frac{5 \pm 1}{2}\]

So the solutions are $x = \frac{5 + 1}{2} = 3$ and $x = \frac{5 - 1}{2} = 2$.

\newpage
\chapter*{Recommended Literature}

\begin{thebibliography}{9}

\bibitem{pythoncrashcourse} Matthes, E. (2019). \textit{Python Crash Course: A Hands-On, Project-Based Introduction to Programming}. No Starch Press.

\bibitem{automatetheboringstuff} Sweigart, A. (2015). \textit{Automate the Boring Stuff with Python: Practical Programming for Total Beginners}. No Starch Press.

\bibitem{fluentpython} Ramalho, L. (2015). \textit{Fluent Python: Clear, Concise, and Effective Programming}. O'Reilly Media.

\bibitem{learningpython} Lutz, M. (2013). \textit{Learning Python}. O'Reilly Media.

\bibitem{pythondatascience} VanderPlas, J. (2016). \textit{Python Data Science Handbook: Essential Tools for Working with Data}. O'Reilly Media.

\bibitem{effectivepython} Slatkin, B. (2015). \textit{Effective Python: 59 Specific Ways to Write Better Python}. Addison-Wesley Professional.

\bibitem{thinkpython} Downey, A. B. (2012). \textit{Think Python: How to Think Like a Computer Scientist}. Green Tea Press.

\bibitem{pythondocs} Python Software Foundation. \textit{Python Documentation}. Retrieved from \url{https://docs.python.org}

\bibitem{pythontutorial} Python Software Foundation. \textit{Python Tutorial}. Retrieved from \url{https://docs.python.org/3/tutorial/index.html}

\bibitem{realpython} Real Python. \textit{Python Tutorials and Articles}. Retrieved from \url{https://realpython.com}

\end{thebibliography}

% THE DOCUMENT IS ESSENTIALLY DONE AT THIS POINT, NO NEED TO EDIT ANYTHING BELOW THIS______________________________________________________________________________________________
% Bibliography
\newpage
\printbibliography
\end{document}
